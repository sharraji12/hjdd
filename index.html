<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Version Updated -->
    <title>Gemini Chat + Mock Test (v9.7 - Multi-PDF Upload)</title>
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
            svg: { fontCache: 'global' },
            options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <!-- <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script> -->

    <!-- *** ADDED: Google Generative AI SDK Script *** -->
    <!-- Use type="module" to enable import statements -->
    <script type="module">
        // Make SDK accessible globally after import (needed for non-module parts of the script)
        import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";
        window.GoogleGenerativeAI = GoogleGenerativeAI;
        console.log("GoogleGenerativeAI SDK loaded via module.");
    </script>

    <style>
        /* --- Styles (v9.7 - PDF Button Style Added) --- */
        :root { /* ... Theme Variables ... */
             --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --sidebar-width: 260px; --message-font-size-base: 1rem;
            /* LIGHT */ --sidebar-bg: #f7f7f7; --main-bg: #ffffff; --input-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #2c2c2c; --text-secondary: #5f5f5f; --text-placeholder: #999999; --accent-color: #d97a7a; --user-message-bg: #cce0ff; --user-message-text: #1c1c1c; --ai-message-bg: #f0f0f0; --ai-message-text: #2c2c2c; --button-bg: #f0f0f0; --button-hover-bg: #e0e0e0; --active-item-bg: #e0e0e0; --code-bg: #e8e8e8; --scrollbar-thumb: #ccc; --scrollbar-thumb-hover: #bbb; --app-outer-bg: #e8e8e8; --send-button-bg: var(--accent-color); --send-button-hover-bg: #c76b6b; --send-button-text: #ffffff; --error-bg: #ffebee; --error-text: #c62828; --error-border: #ef9a9a; --message-font-size: var(--message-font-size-base); --delete-button-color: #aaa; --delete-button-hover-color: #dc3545; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color); --preview-bg: var(--button-bg); --preview-border: var(--border-color); --remove-btn-color: var(--text-secondary); --remove-btn-hover-color: var(--error-text);
            /* Audio Specific */
            --record-button-bg: #ff6b6b; --record-button-text: #ffffff; --stop-button-bg: #4a4a4a; --stop-button-text: #ffffff;
        }
        body.dark-theme { /* DARK */ --sidebar-bg: #2a2a2e; --main-bg: #1e1e1e; --input-bg: #2a2a2e; --border-color: #404040; --text-primary: #e0e0e0; --text-secondary: #a0a0a0; --text-placeholder: #777777; --accent-color: #e58b8b; --user-message-bg: #3a4a6b; --user-message-text: #e8e8e8; --ai-message-bg: #333333; --ai-message-text: #e0e0e0; --button-bg: #404040; --button-hover-bg: #505050; --active-item-bg: #454545; --code-bg: #2c2c2e; --scrollbar-thumb: #555; --scrollbar-thumb-hover: #666; --app-outer-bg: #121212; --send-button-bg: var(--accent-color); --send-button-hover-bg: #f09f9f; --send-button-text: #1e1e1e; --error-bg: #5c2b2b; --error-text: #ffcdd2; --error-border: #8c4343; --delete-button-color: #666; --delete-button-hover-color: #f09f9f; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color); --preview-bg: var(--button-bg); --preview-border: var(--border-color); --remove-btn-color: var(--text-secondary); --remove-btn-hover-color: var(--error-text);
            /* Audio Specific */
             --record-button-bg: #ff8787; --record-button-text: #1e1e1e; --stop-button-bg: #777777; --stop-button-text: #e0e0e0;
        }
        body { font-family: var(--font-family); margin: 0; padding: 0; background-color: var(--app-outer-bg); color: var(--text-primary); font-size: 15px; transition: background-color 0.3s ease, color 0.3s ease; }

        /* Layout & Structure */
        .app-container { display: flex; height: 100vh; width: 100vw; overflow: hidden; } .app-container.hidden { display: none; }
        .sidebar { width: var(--sidebar-width); background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; padding: 15px 0; box-sizing: border-box; flex-shrink: 0; transition: background-color 0.3s ease, border-color 0.3s ease, width 0.3s ease; }
        .main-container { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; overflow: hidden; position: relative; }
        .main-content, .review-view { display: none; flex-direction: column; background-color: var(--main-bg); height: 100%; width: 100%; overflow: hidden; transition: background-color 0.3s ease; }
        .main-content.active, .review-view.active { display: flex; }
        .chat-area { flex-grow: 1; overflow-y: auto; padding: 30px 10% 20px; display: flex; flex-direction: column; max-width: 800px; margin: 0 auto; width: 80%; }
        .input-container { padding: 15px 10% 20px; border-top: 1px solid var(--border-color); background-color: var(--input-bg); max-width: 800px; margin: 0 auto; width: 80%; transition: background-color 0.3s ease, border-color 0.3s ease; display: none; }

        /* Sidebar Elements */
         .sidebar-header { padding: 10px 20px; font-size: 1.1em; font-weight: 600; color: var(--text-primary); }
         .sidebar-section { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; margin-top: 10px; }
         .sidebar-section-title { padding: 5px 20px; font-size: 0.85em; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; flex-shrink: 0; }
         /* All Tests Section */
         #all-tests-section { border-bottom: 1px solid var(--border-color); margin-bottom: 10px; padding-bottom: 10px; flex-shrink: 0; display: flex; flex-direction: column; max-height: 40%; display: none; }
         #all-tests-section.visible { display: flex; }
         #test-search-input { width: calc(100% - 40px); padding: 8px 10px; margin: 5px 15px 10px 15px; border: 1px solid var(--input-border-color); background-color: var(--input-bg); color: var(--text-primary); border-radius: 6px; font-size: 0.9em; box-sizing: border-box; }
         #test-search-input:focus { outline: none; border-color: var(--input-focus-border-color); }
         #all-tests-list { overflow-y: auto; padding: 0 15px; flex-grow: 1; }
         #all-tests-list::-webkit-scrollbar { width: 6px; } #all-tests-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} #all-tests-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .test-list-item { padding: 8px 10px; margin-bottom: 5px; border-radius: 6px; background-color: var(--button-bg); cursor: default; transition: background-color 0.2s ease; display: flex; flex-direction: column; gap: 5px; border: 1px solid var(--border-color); }
         .test-list-item.hidden-by-search { display: none; }
         .test-list-item .no-search-results { padding:10px;color:var(--text-secondary);font-size:0.9em; }
         .test-item-info { font-size: 0.9em; color: var(--text-primary); position: relative; padding-right: 50px; }
         .test-item-title { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; }
         .test-item-details { font-size: 0.8em; color: var(--text-secondary); }
         .test-item-actions { display: flex; justify-content: flex-start; gap: 8px; margin-top: 5px; /* Add some space */ }
         .test-item-actions button, .test-item-actions select { background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 4px 8px; font-size: 0.8em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease; }
         .test-item-actions button:hover, .test-item-actions select:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .test-item-actions select:disabled { opacity: 0.6; cursor: not-allowed; }
        .test-item-controls { position: absolute; right: 5px; top: 0; display: flex; gap: 5px; }
        .test-item-controls button { background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.1em; padding: 0 3px; line-height: 1; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
        .test-item-controls button:hover { opacity: 1; color: var(--delete-button-hover-color); }
        .test-item-edit-mode { display: flex; align-items: center; }
        .test-item-edit-mode input[type="text"] { flex-grow: 1; padding: 2px 4px; margin-right: 5px; border: 1px solid var(--input-focus-border-color); background-color: var(--input-bg); color: var(--text-primary); border-radius: 3px; font-size: 0.95em; }
        .test-item-edit-mode button { font-size: 0.9em; padding: 2px 5px; background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 3px; cursor: pointer; margin-left: 3px; }
        .test-item-edit-mode button:hover { background-color: var(--button-hover-bg); }
         /* Chat List */
         .start-chat-button { display: flex; align-items: center; gap: 8px; background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; padding: 10px 15px; margin: 0 15px 10px 15px; font-size: 0.95em; font-weight: 500; cursor: pointer; text-align: left; transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease; flex-shrink: 0; }
         .start-chat-button:hover { background-color: var(--button-hover-bg); } .start-chat-button svg { fill: currentColor; width: 16px; height: 16px; }
         .start-chat-button:disabled { opacity: 0.6; cursor: not-allowed; }
         .chat-list { overflow-y: auto; padding: 0 15px; margin-bottom: 10px; flex-grow: 1; }
         .chat-list::-webkit-scrollbar { width: 6px; } .chat-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} .chat-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .chat-list-item { padding: 8px 30px 8px 10px; margin-bottom: 4px; border-radius: 6px; font-size: 0.9em; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-secondary); transition: background-color 0.2s ease, color 0.2s ease; position: relative; }
         .chat-list-item:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .chat-list-item.active { background-color: var(--active-item-bg); color: var(--text-primary); font-weight: 500; }
         .delete-chat-button { position: absolute; right: 6px; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.3em; line-height: 1; padding: 0; display: none; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
         .chat-list-item:hover .delete-chat-button { display: block; }
         .delete-chat-button:hover { color: var(--delete-button-hover-color); opacity: 1; }
         /* Sidebar Footer */
         .sidebar-footer { border-top: 1px solid var(--border-color); padding: 10px 15px; transition: border-color 0.3s ease; flex-shrink: 0; }
         .sidebar-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
         .text-size-controls span, .theme-toggle span { font-size: 0.85em; color: var(--text-secondary); }
         .text-size-buttons button, .theme-toggle button { background: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 2px 8px; margin-left: 5px; cursor: pointer; font-size: 1.1em; line-height: 1; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
         .text-size-buttons button:hover, .theme-toggle button:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .text-size-buttons button:disabled, .theme-toggle button:disabled { opacity: 0.6; cursor: not-allowed; }
         .account-info { display: flex; align-items: center; gap: 10px; font-size: 0.9em; margin-top: 10px; }
         .account-avatar { width: 30px; height: 30px; border-radius: 50%; background-color: #6c757d; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; }
         .account-details { overflow: hidden; }
         .account-email { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
         .account-plan { font-size: 0.85em; color: var(--text-secondary); }
         #auth-controls { margin-top: 15px; text-align: center; }
         #auth-controls button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 8px 15px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease; }
         #auth-controls button:hover { background-color: var(--button-hover-bg); }
         #logout-btn { display: none; }

        /* Chat Area Elements */
        .greeting { font-size: 1.8em; font-weight: 600; margin-bottom: 40px; color: var(--text-primary); } .greeting .asterisk { color: var(--accent-color); font-size: 1.2em; margin-right: 5px; display: inline-block; vertical-align: middle; }
        .message { padding: 12px 18px; border-radius: 18px; max-width: 80%; word-wrap: break-word; line-height: 1.6; margin-bottom: 15px; font-size: var(--message-font-size); transition: background-color 0.3s ease, color 0.3s ease; }
        .user-message { background-color: var(--user-message-bg); color: var(--user-message-text); align-self: flex-end; border-bottom-right-radius: 5px; }
        .ai-message { background-color: var(--ai-message-bg); color: var(--ai-message-text); align-self: flex-start; border-bottom-left-radius: 5px; }
        .ai-message strong { font-weight: 600; } .ai-message em { font-style: italic; }
        .ai-message pre { background-color: var(--code-bg); color: var(--text-primary); padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 0.9em; transition: background-color 0.3s ease, color 0.3s ease; }
        .ai-message code { font-family: monospace; background-color: var(--code-bg); color: var(--text-primary); padding: 2px 4px; border-radius: 3px; transition: background-color 0.3s ease, color 0.3s ease;}
        .ai-message pre code { background-color: transparent; padding: 0; }
        .ai-message.thinking { background-color: transparent; color: var(--text-secondary); font-style: italic; }
        .error-message { background-color: var(--error-bg); color: var(--error-text); border: 1px solid var(--error-border); align-self: flex-start; transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;}
        .info-message { text-align: center; color: var(--text-secondary); padding: 50px 20px; font-style: italic; }
        /* Display message with multiple media indicator */
        .message .multi-media-indicator { font-size: 0.9em; color: var(--text-secondary); margin-top: 8px; display: block; font-style: italic;}
        .message mjx-container { color: inherit !important; font-size: inherit !important; }
        /* Embedded Images & Videos */
        .message img.chat-image, .message img.uploaded-image { max-width: 100%; height: auto; border-radius: 8px; margin-top: 8px; cursor: pointer; display: block; }
        .message img.uploaded-image { border: 1px solid var(--border-color); margin-bottom: 5px; /* Space between uploaded img and text */ }
        .message .youtube-embed-container { margin-top: 10px; }
        .message iframe.chat-video { max-width: 100%; aspect-ratio: 16 / 9; border: none; border-radius: 8px; }
        /* Audio display in chat */
        .message .chat-audio-player { margin-top: 10px; width: 100%; max-width: 350px; }
        .message .chat-audio-player audio { width: 100%; height: 40px; border-radius: 20px; /* Optional styling */ }

        /* Input Area Elements */
        .suggestions { display: none; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .suggestion-chip { background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 16px; padding: 8px 15px; font-size: 0.9em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
        .suggestion-chip:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .input-box { display: flex; align-items: flex-end; background-color: var(--main-bg); border: 1px solid var(--input-border-color); border-radius: 12px; padding: 5px 5px 5px 15px; position: relative; transition: background-color 0.3s ease, border-color 0.3s ease; }
        .input-box:focus-within { border-color: var(--input-focus-border-color); }
        /* Input Buttons */
        .input-buttons { display: flex; align-self: center; margin-right: 5px; gap: 3px; }
        /* *** ADDED/MODIFIED: PDF button style *** */
        #image-upload-button, #pdf-upload-button, #audio-upload-button, #record-audio-button { background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 1.4em; padding: 0 4px; line-height: 1; transition: color 0.2s ease, opacity 0.2s ease; }
        #image-upload-button:hover, #pdf-upload-button:hover, #audio-upload-button:hover, #record-audio-button:hover:not(.recording) { color: var(--text-primary); }
        #image-upload-button:disabled, #pdf-upload-button:disabled, #audio-upload-button:disabled, #record-audio-button:disabled:not(.recording) { opacity: 0.5; cursor: not-allowed; color: var(--text-secondary); }
        #record-audio-button.recording { color: var(--record-button-bg); animation: pulse 1.5s infinite; }
        #record-audio-button.recording:disabled { color: var(--stop-button-bg); opacity: 0.7; animation: none; cursor: default; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        #user-input { flex-grow: 1; border: none; outline: none; padding: 10px 5px; font-size: 1rem; background-color: transparent; resize: none; min-height: 48px; max-height: 250px; line-height: 1.5; color: var(--text-primary); font-family: var(--font-family); }
        #user-input::placeholder { color: var(--text-placeholder); }
        .mcq-mode-control { display: flex; align-items: center; margin-left: 10px; padding-bottom: 8px; flex-shrink: 0; }
        .mcq-mode-control input[type="checkbox"] { margin-right: 5px; accent-color: var(--accent-color); cursor: pointer;}
        .mcq-mode-control label { font-size: 0.85em; color: var(--text-secondary); cursor: pointer; user-select: none;}
        #send-button { background-color: var(--send-button-bg); color: var(--send-button-text); border: none; border-radius: 8px; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-left: 10px; transition: background-color 0.2s ease; padding: 0; flex-shrink: 0; }
        #send-button:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #send-button:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.6; }
        #send-button svg { width: 20px; height: 20px; fill: currentColor; }

        /* Media Previews */
        /* *** MODIFIED: Adjusted for PDF file names *** */
        #media-preview-container { margin-bottom: 10px; padding: 8px; background-color: var(--preview-bg); border: 1px solid var(--preview-border); border-radius: 8px; display: none; /* Initially hidden */ flex-direction: column; /* Stack previews and info/remove */ gap: 8px; }
        /* Container for multiple image thumbnails OR PDF list */
        #image-previews-list { display: flex; gap: 8px; flex-wrap: wrap; max-height: 120px; /* Limit height */ overflow-y: auto; }
        /* Styles for PDF preview item (just text for now) */
        .pdf-preview-item { background-color: var(--main-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-size: 0.85em; display: flex; align-items: center; gap: 6px; }
        .pdf-preview-item span { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; }
        .pdf-preview-item button { /* Individual remove button for PDF item */ background: none; border: none; color: var(--remove-btn-color); cursor: pointer; font-size: 1.1em; line-height: 1; padding: 0 2px; margin-left: 4px; flex-shrink: 0; }
        .pdf-preview-item button:hover { color: var(--remove-btn-hover-color); }
        /* Styles for Image preview */
        .image-preview-item { position: relative; }
        .image-preview-item img { max-height: 50px; max-width: 80px; height: auto; width: auto; border-radius: 4px; object-fit: cover; display: block; border: 1px solid var(--border-color); }
        .remove-image-item-button { position: absolute; top: -5px; right: -5px; background-color: rgba(0, 0, 0, 0.6); color: white; border: none; border-radius: 50%; width: 16px; height: 16px; font-size: 10px; line-height: 16px; text-align: center; cursor: pointer; opacity: 0.8; transition: opacity 0.2s ease; }
        .remove-image-item-button:hover { opacity: 1; }
        /* Single audio preview */
        #preview-audio-container { display: flex; align-items: center; gap: 8px; display: none; /* Hidden by default */ }
        #preview-audio-container audio { height: 30px; max-width: 250px; }
        /* Footer: Info Text and Remove All Button */
        .media-preview-footer { display: flex; align-items: center; width: 100%; }
        #media-preview-info { font-size: 0.85em; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; /* Now used mainly for overall count */ }
        #remove-media-button { background: none; border: none; color: var(--remove-btn-color); cursor: pointer; font-size: 1.4em; line-height: 1; padding: 0 5px; transition: color 0.2s ease; margin-left: auto; /* Push to the right */ flex-shrink: 0; }
        #remove-media-button:hover { color: var(--remove-btn-hover-color); }

         /* Recording Status */
         #recording-status { font-size: 0.85em; color: var(--text-secondary); margin-bottom: 5px; display: none; text-align: center; padding: 3px 0; }
         #recording-status.visible { display: block; }

        .thinking::after { content: ' .'; animation: dots 1s steps(3, end) infinite; display: inline-block; }
        @keyframes dots { 0%, 20% { content: ' .'; } 40% { content: ' ..'; } 60%, 100% { content: ' ...'; } }
         .start-test-button { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 8px 15px; margin-top: 10px; cursor: pointer; font-weight: 500; display: inline-block; transition: background-color 0.2s ease; }
         .start-test-button:hover { background-color: var(--send-button-hover-bg); }

        /* Mock Test & Review View Styles */
        /* ... (These remain the same) ... */
        .mock-test-view { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--main-bg); z-index: 100; flex-direction: column; padding: 20px; box-sizing: border-box; transition: background-color 0.3s ease; }
        .mock-test-view.active { display: flex; }
        .test-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .test-header h2 { margin: 0; font-size: 1.3em; color: var(--text-primary); }
        .test-info { display: flex; align-items: center; }
        .test-info span { margin-left: 15px; font-size: 0.95em; color: var(--text-secondary); }
        #test-language-toggle, #review-language-toggle { margin-left: 15px; padding: 3px 8px; font-size: 0.8em; cursor: pointer; background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; transition: background-color 0.2s ease, color 0.2s ease; }
        #test-language-toggle:hover, #review-language-toggle:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .test-content { flex-grow: 1; overflow-y: auto; padding: 10px 20px; }
        .test-question-container { margin-bottom: 25px; }
        .test-question-number { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .test-question { font-size: 1.1em; line-height: 1.5; margin-bottom: 15px; color: var(--text-primary); }
        .test-options label { display: block; margin-bottom: 12px; background-color: var(--button-bg); padding: 12px 15px; border-radius: 6px; border: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease; color: var(--text-primary); }
        .test-options label:hover { background-color: var(--button-hover-bg); }
        .test-options input[type="radio"] { margin-right: 10px; accent-color: var(--accent-color); cursor: pointer;}
        .test-navigation { display: flex; justify-content: space-between; padding-top: 15px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; }
        .test-navigation button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 10px 20px; cursor: pointer; font-size: 0.95em; transition: background-color 0.2s ease; }
        .test-navigation button:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        .test-navigation button#submit-test-btn { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color); }
        .test-navigation button#submit-test-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        .test-navigation button:disabled { opacity: 0.5; cursor: not-allowed; }
        .review-view { padding: 20px; box-sizing: border-box; background-color: var(--main-bg); }
        .review-header { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        .review-header h2 { margin: 0 0 10px 0; font-size: 1.3em; color: var(--text-primary); }
        .review-summary { display: inline; }
        .review-summary span { margin-right: 20px; font-size: 1em; color: var(--text-primary); }
        .review-summary .score-correct { color: #28a745; font-weight: bold;} .review-summary .score-incorrect { color: #dc3545; font-weight: bold;} .review-summary .score-skipped { color: #fd7e14; font-weight: bold;}
        .review-filters { margin-top: 10px; margin-bottom: 15px; }
        .review-filters button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 5px 12px; margin-right: 8px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease, border-color 0.2s ease; }
        .review-filters button:hover { background-color: var(--button-hover-bg); }
        .review-filters button.active-filter { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color);}
        .review-content { flex-grow: 1; overflow-y: auto; padding-right: 10px; }
        .review-item { margin-bottom: 15px; padding: 15px; border: 1px solid var(--border-color); border-radius: 6px; background-color: var(--button-bg); transition: background-color 0.3s ease, border-color 0.3s ease; }
        .review-item.hidden-by-filter { display: none; }
        .review-item-qnum { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .review-item-question { margin-bottom: 10px; line-height: 1.5; color: var(--text-primary); }
        .review-item-details span { display: block; margin-bottom: 5px; font-size: 0.95em; color: var(--text-primary); }
        .review-item-details .correct-answer { color: #28a745; font-weight: bold; }
        .review-item-details .user-answer-correct { color: #28a745; } .review-item-details .user-answer-incorrect { color: #dc3545; text-decoration: line-through; } .review-item-details .user-answer-skipped { color: #fd7e14; font-style: italic; }
        .review-item-explanation { margin-top: 8px; font-size: 0.9em; color: var(--text-secondary); border-left: 3px solid var(--border-color); padding-left: 8px; line-height: 1.4; }
        .review-footer { text-align: center; padding-top: 20px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; display: flex; justify-content: center; gap: 15px; }
        #exit-review-btn, #save-review-btn { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 10px 25px; cursor: pointer; font-size: 1em; transition: background-color 0.2s ease; display: none; }
        #exit-review-btn:hover, #save-review-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #save-review-btn { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); }
        #save-review-btn:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        #save-review-btn:disabled { opacity: 0.6; cursor: not-allowed; background-color: #cccccc; border-color: #aaaaaa; }

        /* Responsive Design */
        @media (max-width: 768px) {
            :root { --sidebar-width: 200px; }
            .sidebar { padding: 10px 0; }
            .main-container { }
            .chat-area, .input-container { width: 95%; padding-left: 2.5%; padding-right: 2.5%; max-width: none; }
            .chat-area { padding-top: 15px; padding-bottom: 10px; }
            .input-container { padding-top: 10px; padding-bottom: 10px; }
            .message { max-width: 90%; font-size: calc(var(--message-font-size) * 0.95); }
            /* Input buttons responsive */
            /* *** ADDED/MODIFIED: PDF button responsive style *** */
            #image-upload-button, #pdf-upload-button, #audio-upload-button, #record-audio-button { font-size: 1.3em; padding: 0 3px; }
             /* Media Preview responsive */
            #media-preview-container { padding: 6px; gap: 6px; }
             /* Image/PDF list responsive */
            #image-previews-list { gap: 5px; max-height: 100px; }
            /* PDF item responsive */
            .pdf-preview-item { padding: 3px 6px; font-size: 0.8em; }
            /* Image item responsive */
            .image-preview-item img { max-height: 40px; }
            .remove-image-item-button, .pdf-preview-item button { width: 14px; height: 14px; font-size: 9px; line-height: 14px; }
            /* Audio preview responsive */
            #preview-audio-container audio { max-width: 180px; height: 28px; }
            #media-preview-info { font-size: 0.8em; }
            #remove-media-button { font-size: 1.3em; }
            .input-box { padding: 5px 5px 5px 10px; }
             #user-input { min-height: 40px; font-size: 0.95rem; }
             #send-button { width: 32px; height: 32px; }
             .mcq-mode-control label { font-size: 0.8em; }
             /* Test/Review Mobile Styles */
            .mock-test-view, .review-view { padding: 10px; }
            .test-header, .review-header { margin-bottom: 15px; padding-bottom: 8px; flex-direction: column; align-items: flex-start; }
            .test-header h2, .review-header h2 { font-size: 1.1em; margin-bottom: 5px;}
            .test-info, .review-summary { margin-bottom: 5px; }
            .test-info span, .review-summary span { margin-left: 0; margin-right: 10px; font-size: 0.9em; display: inline-block; margin-bottom: 3px;}
            #test-language-toggle, #review-language-toggle { margin-left: 0; margin-top: 5px; font-size: 0.75em;}
            .test-content, .review-content { padding: 5px; }
            .test-question, .review-item-question { font-size: 1em; }
            .test-options label, .review-item { padding: 10px; font-size: 0.95em;}
            .review-filters { margin-top: 5px; }
            .review-filters button { padding: 4px 8px; font-size: 0.85em; margin-right: 5px;}
            .test-navigation, .review-footer { padding-top: 10px; }
            .test-navigation button, #exit-review-btn, #save-review-btn { padding: 8px 15px; font-size: 0.9em; }
        }

    </style>
</head>
<body>

    <div class="app-container" id="app-container">
        <div class="sidebar">
             <!-- Sidebar content -->
             <div class="sidebar-header">Gemini Chat</div>
             <div id="all-tests-section">
                 <div class="sidebar-section-title">All Tests</div>
                 <input type="search" id="test-search-input" placeholder="Search tests..." disabled>
                 <div class="all-tests-list" id="all-tests-list">
                      <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Login to see saved tests.</div>
                 </div>
             </div>
             <div class="sidebar-section">
                 <button class="start-chat-button" id="start-chat" disabled> <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg>
                      Start new chat
                 </button>
                 <div class="sidebar-section-title">Chats</div>
                 <div class="chat-list" id="chat-list">
                      <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in to see chats.</div>
                 </div>
             </div>
             <div class="sidebar-footer">
                  <div class="sidebar-controls">
                      <div class="text-size-controls">
                          <span>Text Size</span>
                          <div class="text-size-buttons"> <button id="decrease-text-size" title="Decrease text size" disabled>-</button> <button id="increase-text-size" title="Increase text size" disabled>+</button> </div>
                      </div>
                      <div class="theme-toggle"> <button id="theme-toggle-button" title="Toggle Theme" disabled>☀️</button> </div>
                  </div>
                   <div id="auth-controls"> <button id="login-google-btn">Login with Google</button> <button id="logout-btn" style="display: none;">Logout</button> </div>
                   <div class="account-info">
                       <div class="account-avatar" id="account-avatar">?</div>
                       <div class="account-details"> <div class="account-email" id="account-email">Not logged in</div> <div class="account-plan" id="account-plan"></div> </div>
                   </div>
             </div>
        </div>

        <div class="main-container">
            <div class="main-content active" id="main-content-chat">
                 <div class="chat-area" id="chat-area">
                     <!-- Chat messages will be loaded here -->
                 </div>
                 <div class="input-container" id="input-container">
                     <div class="suggestions" id="suggestions">
                          <button class="suggestion-chip" data-prompt="Summarize this document">Summarize this document</button>
                          <button class="suggestion-chip" data-prompt="Extract key points from this PDF">Extract key points from this PDF</button>
                          <button class="suggestion-chip" data-prompt="Describe this image">Describe this image</button>
                          <button class="suggestion-chip" data-prompt="Transcribe this audio">Transcribe this audio</button>
                     </div>
                    <!-- Media Preview Container -->
                    <div id="media-preview-container">
                        <!-- Image / PDF Previews (Combined List Now) -->
                        <div id="image-previews-list">
                            <!-- Thumbnails (Image) or File Items (PDF) will be added here by JS -->
                        </div>
                        <!-- Audio Preview (Single) -->
                        <div id="preview-audio-container">
                           <audio id="preview-audio" controls></audio>
                        </div>
                        <!-- Footer: Info and Remove All Button -->
                        <div class="media-preview-footer">
                            <span id="media-preview-info"></span>
                            <button id="remove-media-button" title="Remove all media">&times;</button>
                        </div>
                    </div>
                    <!-- Recording Status -->
                    <div id="recording-status">Recording... <span>0s</span></div>

                    <div class="input-box">
                         <!-- Hidden File Inputs -->
                         <input type="file" id="image-upload-input" accept="image/*" style="display: none;" multiple>
                         <!-- *** ADDED: PDF Input *** -->
                         <input type="file" id="pdf-upload-input" accept="application/pdf" style="display: none;" multiple>
                         <input type="file" id="audio-upload-input" accept="audio/wav, audio/mp3, audio/mpeg, audio/aac, audio/ogg, audio/flac, audio/aiff" style="display: none;">

                         <!-- Buttons -->
                         <div class="input-buttons">
                             <button id="image-upload-button" title="Upload image(s) (Max 16MB total, 5 files)" disabled>📎</button>
                             <!-- *** ADDED: PDF Button *** -->
                             <button id="pdf-upload-button" title="Upload PDF file(s)" disabled>📄</button>
                             <button id="audio-upload-button" title="Upload audio file (Max 10MB)" disabled>🎵</button>
                             <button id="record-audio-button" title="Record audio" disabled>🎙️</button>
                         </div>

                         <textarea id="user-input" placeholder="Enter prompt, attach media, or paste URL" rows="1"></textarea>
                         <div class="mcq-mode-control"> <input type="checkbox" id="mcq-mode-checkbox" title="Check to generate MCQs based on your prompt"> <label for="mcq-mode-checkbox">MCQs?</label> </div>
                         <button id="send-button" title="Send message" disabled> <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
                        </button>
                    </div>
                 </div>
            </div>
            <!-- Review View -->
            <div class="review-view" id="review-view">
                 <div class="review-header">
                     <h2 id="review-title">Test Review</h2>
                     <div>
                         <div class="review-summary" id="review-summary"></div>
                         <!-- Removed Tamil button, keep only English context for now -->
                         <!-- <button id="review-language-toggle" style="margin-left: 15px; padding: 3px 8px; font-size: 0.8em; vertical-align: middle;">தமிழ்</button> -->
                      </div>
                     <div class="review-filters" id="review-filters" style="display: none;"> <button data-filter="all" class="active-filter">All</button> <button data-filter="incorrect">Incorrect</button> <button data-filter="skipped">Skipped</button> </div>
                 </div>
                 <div class="review-content" id="review-content"></div>
                 <div class="review-footer"> <button id="save-review-btn">Save Review</button> <button id="exit-review-btn">Back</button> </div>
              </div>
        </div>
    </div>
    <!-- Mock Test View -->
    <div class="mock-test-view" id="mock-test-view">
         <div class="test-header">
            <h2 id="test-title">Mock Test</h2>
            <div class="test-info">
                <span id="question-counter">Q: 1 / N</span>
                <span id="test-timer">Time: 00:00</span>
                <!-- Removed Tamil button -->
                <!-- <button id="test-language-toggle" style="margin-left: 15px; padding: 3px 8px; font-size: 0.8em;">தமிழ்</button> -->
             </div>
         </div>
         <div class="test-content">
            <div class="test-question-container"> <div class="test-question-number" id="test-question-number"></div> <div class="test-question" id="test-question"></div> <div class="test-options" id="test-options"></div> </div>
         </div>
         <div class="test-navigation"> <button id="prev-question-btn" disabled>Previous</button> <button id="next-question-btn">Next</button> <button id="submit-test-btn">Submit Test</button> </div>
    </div>


    <script>
        // --- Firebase Config ---
        // !! SECURITY WARNING !! Replace with your actual config and secure properly.
        const firebaseConfig = {
          apiKey: "AIzaSyDgw604fe5jnNu4kTOv1cQ-3n7PL8gcN58", // <- REPLACE
          authDomain: "krish-c5db8.firebaseapp.com",
          projectId: "krish-c5db8",
          storageBucket: "krish-c5db8.appspot.com",
          messagingSenderId: "217175257890",
          appId: "1:217175257890:web:209f0f290eabab6b1fab7b",
          measurementId: "G-97SHYGL2J4"
        };

        // --- Initialize Firebase ---
        firebase.initializeApp(firebaseConfig);
        const fbAuth = firebase.auth();
        const db = firebase.firestore();
        // const storage = firebase.storage(); // Not used currently

        // --- DOM Elements ---
        const appContainer = document.getElementById('app-container');
        const chatArea = document.getElementById('chat-area');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const suggestionsContainer = document.getElementById('suggestions');
        const startChatButton = document.getElementById('start-chat');
        const chatListContainer = document.getElementById('chat-list');
        const allTestsSection = document.getElementById('all-tests-section');
        const testSearchInput = document.getElementById('test-search-input');
        const allTestsListContainer = document.getElementById('all-tests-list');
        const accountEmail = document.getElementById('account-email');
        const accountAvatar = document.getElementById('account-avatar');
        const accountPlan = document.getElementById('account-plan');
        const decreaseTextBtn = document.getElementById('decrease-text-size');
        const increaseTextBtn = document.getElementById('increase-text-size');
        const themeToggleButton = document.getElementById('theme-toggle-button');
        const mainContainer = document.querySelector('.main-container');
        const chatView = document.getElementById('main-content-chat');
        const testView = document.getElementById('mock-test-view');
        const reviewView = document.getElementById('review-view');
        const inputContainer = document.getElementById('input-container');
        const mcqModeCheckbox = document.getElementById('mcq-mode-checkbox');
        const loginBtn = document.getElementById('login-google-btn');
        const logoutBtn = document.getElementById('logout-btn');
        // Test & Review Elements
        const testTitle = document.getElementById('test-title');
        const questionCounter = document.getElementById('question-counter');
        const testTimer = document.getElementById('test-timer');
        const testQuestionNumber = document.getElementById('test-question-number');
        const testQuestion = document.getElementById('test-question');
        const testOptionsContainer = document.getElementById('test-options');
        const prevQuestionBtn = document.getElementById('prev-question-btn');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const submitTestBtn = document.getElementById('submit-test-btn');
        // const testLanguageToggle = document.getElementById('test-language-toggle'); // Removed
        const reviewTitle = document.getElementById('review-title');
        const reviewSummary = document.getElementById('review-summary');
        const reviewContent = document.getElementById('review-content');
        const exitReviewBtn = document.getElementById('exit-review-btn');
        const reviewFilters = document.getElementById('review-filters');
        const saveReviewBtn = document.getElementById('save-review-btn');
        // const reviewLanguageToggle = document.getElementById('review-language-toggle'); // Removed
        // Media Elements
        const imageUploadButton = document.getElementById('image-upload-button');
        const imageUploadInput = document.getElementById('image-upload-input');
        // *** ADDED: PDF Elements ***
        const pdfUploadButton = document.getElementById('pdf-upload-button');
        const pdfUploadInput = document.getElementById('pdf-upload-input');
        const audioUploadButton = document.getElementById('audio-upload-button');
        const audioUploadInput = document.getElementById('audio-upload-input');
        const recordAudioButton = document.getElementById('record-audio-button');
        // Media Preview Elements
        const mediaPreviewContainer = document.getElementById('media-preview-container');
        const imagePreviewsList = document.getElementById('image-previews-list'); // Container for image thumbs AND pdf items
        const previewAudioContainer = document.getElementById('preview-audio-container');
        const previewAudio = document.getElementById('preview-audio');
        const mediaPreviewInfo = document.getElementById('media-preview-info'); // Now shows overall count
        const removeMediaButton = document.getElementById('remove-media-button'); // Renamed to remove *all* media
        // Recording Status
        const recordingStatus = document.getElementById('recording-status');
        const recordingTimerSpan = recordingStatus.querySelector('span');


        // --- Config & Constants ---
        const MODEL_NAME = "gemini-1.5-flash-latest";
        // const API_URL_BASE = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=`; // <- No longer used for sending, SDK handles it
        const STORAGE_KEY_API_KEY = 'geminiApiKey_insecureDemo';
        const NEW_CHAT_TITLE = "(New Chat)";
        const TEXT_SIZE_STEP = 0.1;
        const MIN_TEXT_SIZE_MULTIPLIER = 0.7;
        const MAX_TEXT_SIZE_MULTIPLIER = 1.5;
        const LIGHT_THEME_ICON = '☀️';
        const DARK_THEME_ICON = '🌙';
        const DELETE_ICON = '×';
        const EDIT_TEST_ICON = '✏️';
        const DELETE_TEST_ICON = '🗑️';
        const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})(?:\S+)?/i;
        const imageUrlRegex = /(?<!src=["'])(?<!href=["'])(https?:\/\/[^\s()<>]+?\.(?:jpg|jpeg|png|gif|webp|bmp))/gi;
        const MAX_IMAGE_SIZE_MB = 4;
        const MAX_TOTAL_IMAGE_SIZE_MB = 16; // Limit for multiple images combined (client-side approx)
        const MAX_IMAGE_COUNT = 5; // Limit number of images
        // *** ADDED: PDF Limits (Client-side checks, server enforces more) ***
        const MAX_PDF_SIZE_MB = 50; // Generous client-side limit for File API
        const MAX_PDF_COUNT = 5; // Arbitrary limit to prevent UI clutter/potential abuse
        const MAX_AUDIO_SIZE_MB = 10;
        const SUPPORTED_AUDIO_MIMES = ['audio/wav', 'audio/mp3', 'audio/mpeg', 'audio/aiff', 'audio/aac', 'audio/ogg', 'audio/flac'];
        const RECORDING_TIME_LIMIT_SECONDS = 300; // 5 minutes

        // --- State Variables ---
        let API_KEY = '';
        let genAI = null; // *** ADDED: GoogleGenerativeAI SDK instance ***
        let currentUser = null;
        let activeChatId = null;
        let currentChatHistory = [];
        let currentTextSizeMultiplier = 1.0;
        let currentTheme = 'light';
        let isTestMode = false;
        let isReviewMode = false;
        let currentTestMCQs = [];
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let testStartTime = null;
        let testTimerInterval = null;
        let reviewResultsCache = null;
        let cameFromAllTestsList = false;
        let activeChatListener = null;
        let chatListListener = null;
        let testListListener = null;
        let isDeletingChat = false;
        let allSavedTestsData = [];
        // Removed language state
        // Multi-media state
        // *** MODIFIED: Can now hold { type: 'pdf', file, name, id } ***
        let selectedMediaItems = []; // Array to hold objects: { type: 'image'/'audio'/'pdf', file, base64?, mimeType?, name, id }
        let nextMediaId = 0; // Simple ID generator for preview items

        // Audio Recording State
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingStartTime = null;
        let recordingTimerInterval = null;
        let recorderStream = null;

        // --- Initialization ---
        initializeApp();

        // --- Event Listeners ---
        sendButton.addEventListener('click', handleSendMessage);
        userInput.addEventListener('input', autoGrowTextarea);
        userInput.addEventListener('keydown', handleInputKeydown);
        suggestionsContainer.addEventListener('click', handleSuggestionClick);
        startChatButton.addEventListener('click', createNewChat);
        chatListContainer.addEventListener('click', handleChatListClick);
        allTestsListContainer.addEventListener('click', handleAllTestsListClick);
        testSearchInput.addEventListener('input', filterTestsInSidebar);
        decreaseTextBtn.addEventListener('click', () => adjustTextSize(-TEXT_SIZE_STEP));
        increaseTextBtn.addEventListener('click', () => adjustTextSize(TEXT_SIZE_STEP));
        themeToggleButton.addEventListener('click', toggleTheme);
        prevQuestionBtn.addEventListener('click', () => handleTestNavigation('prev'));
        nextQuestionBtn.addEventListener('click', () => handleTestNavigation('next'));
        submitTestBtn.addEventListener('click', submitTest);
        // testLanguageToggle.addEventListener('click', toggleTestLanguage); // Removed
        exitReviewBtn.addEventListener('click', exitReview);
        chatArea.addEventListener('click', handleChatAreaClick);
        reviewFilters.addEventListener('click', handleReviewFilterClick);
        saveReviewBtn.addEventListener('click', saveTestReviewToCloud);
        // reviewLanguageToggle.addEventListener('click', toggleReviewLanguage); // Removed
        loginBtn.addEventListener('click', signInWithGoogle);
        logoutBtn.addEventListener('click', signOut);
        // Media Listeners
        imageUploadButton.addEventListener('click', () => {
            if (!imageUploadButton.disabled) imageUploadInput.click();
        });
        imageUploadInput.addEventListener('change', handleImageFileSelect);
        // *** ADDED: PDF Listeners ***
        pdfUploadButton.addEventListener('click', () => {
            if (!pdfUploadButton.disabled) pdfUploadInput.click();
        });
        pdfUploadInput.addEventListener('change', handlePdfFileSelect);
        audioUploadButton.addEventListener('click', () => {
            if (!audioUploadButton.disabled) audioUploadInput.click();
        });
        audioUploadInput.addEventListener('change', handleAudioFileSelect);
        recordAudioButton.addEventListener('click', () => {
             if (!recordAudioButton.disabled || isRecording) {
                toggleRecording();
             }
        });
        removeMediaButton.addEventListener('click', removeAllSelectedMedia); // Renamed listener function


        // --- Initialization Functions ---
        async function initializeApp() {
            loadGeminiApiKey(); // Will also initialize genAI instance
            fbAuth.onAuthStateChanged(handleAuthStateChange);
            switchView('chat');
            userInput.focus();
            console.log("App Initialized (v9.7 - Multi-PDF)");
        }

        function loadGeminiApiKey() {
             console.warn("!!! SECURITY WARNING !!! Using insecure API key storage. Use Cloud Functions in production.");
             API_KEY = localStorage.getItem(STORAGE_KEY_API_KEY);
             if(!API_KEY){
                 API_KEY=prompt("--- INSECURE DEMO --- Please enter your Gemini API Key (will be stored insecurely).");
                 if(API_KEY){ localStorage.setItem(STORAGE_KEY_API_KEY, API_KEY); console.log("Saved insecure API Key."); }
                 else { displayError("Gemini API Key is required."); setLoadingState(true, "API Key Missing"); genAI = null; return; } // *** ADDED: Set genAI to null if no key ***
             } else { console.log("Loaded insecure API Key."); }

             // *** ADDED: Initialize GoogleGenerativeAI SDK instance ***
             try {
                 // Check if SDK loaded (it's loaded via <script type="module">)
                 if (window.GoogleGenerativeAI) {
                     genAI = new window.GoogleGenerativeAI(API_KEY);
                     console.log("GoogleGenerativeAI SDK instance created.");
                 } else {
                     console.error("GoogleGenerativeAI SDK not found on window object. Ensure the module script loaded correctly.");
                     displayError("Error: Could not initialize AI SDK.");
                     API_KEY = ''; // Clear invalid key
                     genAI = null;
                 }
             } catch (e) {
                 console.error("Error initializing GoogleGenerativeAI:", e);
                 displayError("Error initializing AI SDK. Check API Key and console.");
                 API_KEY = '';
                 genAI = null;
             }
             setLoadingState(!API_KEY);
        }

        // --- Authentication Functions ---
        async function signInWithGoogle() {
             const provider = new firebase.auth.GoogleAuthProvider();
             try { setLoadingState(true, "Logging in..."); await fbAuth.signInWithPopup(provider); }
             catch (error) { console.error("Google Sign-In Error:", error); displayError(`Login failed: ${error.message || 'Unknown error'}`); setLoadingState(false); }
         }
        async function signOut() {
             try { setLoadingState(true, "Logging out..."); await fbAuth.signOut(); }
             catch (error) { console.error("Sign Out Error:", error); displayError(`Logout failed: ${error.message || 'Unknown error'}`); setLoadingState(false); }
         }

        function handleAuthStateChange(user) {
            console.log("Auth state changed. User:", user ? user.uid : 'None');
            // Clear listeners and UI state
            if (activeChatListener) { activeChatListener(); activeChatListener = null; console.log("Cleared active chat listener."); }
            if (chatListListener) { chatListListener(); chatListListener = null; console.log("Cleared chat list listener.");}
            if (testListListener) { testListListener(); testListListener = null; console.log("Cleared test list listener."); }

            stopRecording(true); // Force stop recording if user logs out/changes

            chatArea.innerHTML = '';
            chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in...</div>';
            allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Login to see tests.</div>';
            allTestsSection.classList.remove('visible');
            testSearchInput.value = ''; testSearchInput.disabled = true;
            activeChatId = null; currentChatHistory = []; isDeletingChat = false; allSavedTestsData = [];
            removeAllSelectedMedia(); // Clear media state

            if (user) {
                currentUser = user; console.log("User logged in:", currentUser.uid);
                loginBtn.style.display = 'none'; logoutBtn.style.display = 'inline-block';
                accountEmail.textContent = currentUser.email || currentUser.displayName || `User`;
                accountAvatar.textContent = (currentUser.displayName || currentUser.email || 'U')[0].toUpperCase();
                accountPlan.textContent = "Firebase User";

                // Enable controls that don't depend on active chat yet
                startChatButton.disabled = false;
                decreaseTextBtn.disabled = false;
                increaseTextBtn.disabled = false;
                themeToggleButton.disabled = false;
                testSearchInput.disabled = false;
                userInput.disabled = false; // Enable text input

                // Initially disable buttons that require an active chat or API key
                const enableMedia = !!(API_KEY && genAI); // *** Check genAI instance too ***
                imageUploadButton.disabled = !enableMedia;
                pdfUploadButton.disabled = !enableMedia; // *** Enable/Disable PDF button ***
                audioUploadButton.disabled = !enableMedia;
                recordAudioButton.disabled = !enableMedia;
                sendButton.disabled = !enableMedia;
                mcqModeCheckbox.disabled = !enableMedia;

                userInput.placeholder = "Select or create a chat"; // English only
                inputContainer.style.display = 'block';
                suggestionsContainer.style.display = 'flex';
                allTestsSection.classList.add('visible');

                loadUserSettings(currentUser.uid);
                loadAndListenForChats(currentUser.uid); // Will update button states if chat selected
                loadAndListenForTests(currentUser.uid);
                setLoadingState(false);
            } else {
                currentUser = null; console.log("User logged out");
                loginBtn.style.display = 'inline-block'; logoutBtn.style.display = 'none';
                accountEmail.textContent = "Not logged in"; accountAvatar.textContent = '?'; accountPlan.textContent = "";

                // Disable all controls
                startChatButton.disabled = true; decreaseTextBtn.disabled = true; increaseTextBtn.disabled = true; themeToggleButton.disabled = true; testSearchInput.disabled = true; userInput.disabled = true;
                imageUploadButton.disabled = true;
                pdfUploadButton.disabled = true; // *** Disable PDF button ***
                audioUploadButton.disabled = true; recordAudioButton.disabled = true;
                sendButton.disabled = true; mcqModeCheckbox.disabled = true;

                userInput.placeholder = "Please log in"; // English only
                inputContainer.style.display = 'none'; suggestionsContainer.style.display = 'none';
                allTestsSection.classList.remove('visible');

                renderGreetingOrLoginPrompt();
                currentTheme = 'light'; applyTheme();
                currentTextSizeMultiplier = 1.0; applyTextSize();
                setLoadingState(false);
            }
        }

        function renderGreetingOrLoginPrompt() {
             chatArea.innerHTML = '';
             const greetingElement = document.createElement('div');
             greetingElement.classList.add('greeting');
             if (currentUser) {
                 greetingElement.innerHTML = `<span class="asterisk">*</span>Good day, ${currentUser.displayName || 'User'}!`;
                 chatArea.appendChild(greetingElement);
                 if (!activeChatId) {
                     displayMessage("Select a chat or start a new one.", 'ai'); // English only
                 } else if (!API_KEY || !genAI) { // *** Check genAI too ***
                     displayMessage("API Key missing or AI SDK failed to initialize. Please check settings.", 'ai', ['error-message']);
                 }
             }
             else {
                 greetingElement.innerHTML = `<span class="asterisk">*</span>Welcome!`;
                 chatArea.appendChild(greetingElement);
                 displayMessage("Please log in to start chatting.", 'ai'); // English only
             }
             scrollToBottom(true);
         }

        // --- Settings (Theme/Text Size) ---
        // (No changes needed)
        async function loadUserSettings(userId) { const userDocRef = db.collection('users').doc(userId); try { const docSnap = await userDocRef.get(); if (docSnap.exists) { const settings = docSnap.data(); currentTheme = settings.theme || 'light'; currentTextSizeMultiplier = settings.textSizeMultiplier || 1.0; console.log("Loaded user settings:", settings); } else { console.log("No user settings found, using defaults."); currentTheme = 'light'; currentTextSizeMultiplier = 1.0; await saveUserSettings(); } } catch (error) { console.error("Error loading user settings:", error); currentTheme = 'light'; currentTextSizeMultiplier = 1.0; } applyTheme(); applyTextSize(); }
        async function saveUserSettings() { if (!currentUser) return; const userDocRef = db.collection('users').doc(currentUser.uid); const settings = { theme: currentTheme, textSizeMultiplier: currentTextSizeMultiplier }; try { await userDocRef.set(settings, { merge: true }); console.log("User settings saved:", settings); } catch (error) { console.error("Error saving user settings:", error); } }
        function applyTheme() { if(currentTheme==='dark'){ document.body.classList.add('dark-theme'); themeToggleButton.textContent=LIGHT_THEME_ICON; themeToggleButton.title="Switch to Light Theme"; } else { document.body.classList.remove('dark-theme'); themeToggleButton.textContent=DARK_THEME_ICON; themeToggleButton.title="Switch to Dark Theme"; } }
        function toggleTheme() { if (!currentUser) return; currentTheme = (currentTheme === 'light') ? 'dark' : 'light'; applyTheme(); saveUserSettings(); }
        function applyTextSize() { const newSize = `calc(var(--message-font-size-base) * ${currentTextSizeMultiplier})`; document.documentElement.style.setProperty('--message-font-size', newSize); decreaseTextBtn.disabled = !currentUser || currentTextSizeMultiplier <= MIN_TEXT_SIZE_MULTIPLIER; increaseTextBtn.disabled = !currentUser || currentTextSizeMultiplier >= MAX_TEXT_SIZE_MULTIPLIER; }
        function adjustTextSize(change) { if (!currentUser) return; let newMultiplier = Math.max(MIN_TEXT_SIZE_MULTIPLIER, Math.min(MAX_TEXT_SIZE_MULTIPLIER, currentTextSizeMultiplier + change)); newMultiplier = Math.round(newMultiplier * 10) / 10; if (newMultiplier !== currentTextSizeMultiplier) { currentTextSizeMultiplier = newMultiplier; applyTextSize(); saveUserSettings(); } }


        // --- Chat Storage & Loading (Firestore) ---
        // (Minor changes to placeholders and logging)
         function loadAndListenForChats(userId) {
            if (chatListListener) { chatListListener(); chatListListener = null; }
            const chatsRef = db.collection('chats').where('userId', '==', userId).orderBy('lastUpdated', 'desc');
            console.log(`Listening for chats for user ${userId}`);
            chatListListener = chatsRef.onSnapshot(snapshot => {
                 if (isDeletingChat) { console.log("Skipping chat list update during delete."); return; }
                const chats = []; snapshot.forEach(doc => { chats.push({ id: doc.id, ...doc.data() }); });
                console.log("Received chat list snapshot:", chats.length, "chats");
                renderSidebarChatList(chats);
                let chatToLoad = null;
                if (activeChatId && chats.some(c => c.id === activeChatId)) {
                    chatToLoad = activeChatId;
                } else if (chats.length > 0) {
                    chatToLoad = chats[0].id;
                    console.log("Active chat gone or none selected, switching to newest:", chatToLoad);
                } else {
                    activeChatId = null;
                    if (activeChatListener) { activeChatListener(); activeChatListener = null; }
                    renderGreetingOrLoginPrompt();
                    setLoadingState(false);
                    // *** Disable media buttons if no active chat ***
                    const enable = false;
                    imageUploadButton.disabled = enable;
                    pdfUploadButton.disabled = enable; // *** PDF Button ***
                    audioUploadButton.disabled = enable;
                    recordAudioButton.disabled = enable;
                    sendButton.disabled = enable;
                    mcqModeCheckbox.disabled = enable;
                    userInput.placeholder = "Create a new chat"; // English only
                }

                 if (chatToLoad && chatToLoad !== activeChatId) {
                     switchChat(chatToLoad);
                 } else if (activeChatId) {
                     highlightActiveChatInSidebar();
                     setLoadingState(false);
                     // *** Enable media buttons if chat active AND api key/sdk ready ***
                     const enable = !!(API_KEY && genAI);
                     imageUploadButton.disabled = !enable;
                     pdfUploadButton.disabled = !enable; // *** PDF Button ***
                     audioUploadButton.disabled = !enable;
                     recordAudioButton.disabled = !enable;
                     sendButton.disabled = !enable;
                     mcqModeCheckbox.disabled = !enable;
                     userInput.placeholder = "Enter prompt, attach media, or paste URL"; // English only
                 } else {
                     setLoadingState(false);
                 }
            }, error => { console.error("Error listening for chats:", error); displayError("Could not load chat list."); chatListContainer.innerHTML = '<div style="padding:10px;color:var(--error-text);">Error loading chats.</div>'; setLoadingState(false); });
        }
        function renderSidebarChatList(chats) {
            chatListContainer.innerHTML = ''; if (!currentUser) { chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">Please log in.</div>'; return; }
            if (chats.length === 0) { chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">No chats yet. Start one!</div>'; }
            else { chats.forEach(chatData => { const itemElement = document.createElement('div'); itemElement.classList.add('chat-list-item'); let title = chatData.title; if (typeof title !== 'string' || !title.trim()) { title = '(Untitled Chat)'; } title = title.trim(); itemElement.textContent = title; itemElement.dataset.id = chatData.id; itemElement.title = title; const deleteBtn = document.createElement('button'); deleteBtn.classList.add('delete-chat-button'); deleteBtn.innerHTML = DELETE_ICON; deleteBtn.title = "Delete chat"; deleteBtn.dataset.id = chatData.id; itemElement.appendChild(deleteBtn); chatListContainer.appendChild(itemElement); }); }
            highlightActiveChatInSidebar();
        }
        function highlightActiveChatInSidebar() { const items = chatListContainer.querySelectorAll('.chat-list-item'); items.forEach(item => { item.classList.toggle('active', item.dataset.id === activeChatId); }); }


        // --- Media Handling Functions (Multi-Image & Multi-PDF Support) ---

        /**
         * Handles selection of one or more image files.
         * Checks for exclusivity with other media types.
         */
        function handleImageFileSelect(event) {
            console.log("handleImageFileSelect triggered");

            // *** MODIFIED: Check for PDF or audio ***
            if (selectedMediaItems.length > 0 && selectedMediaItems.some(item => item.type === 'pdf' || item.type === 'audio')) {
                alert("Cannot select images when PDF(s) or audio are already selected. Please remove other media first.");
                imageUploadInput.value = ''; // Reset input
                return;
            }

            const files = event.target.files;
            if (!files || files.length === 0) {
                console.log("No image files selected or selection cancelled.");
                imageUploadInput.value = '';
                return;
            }

            let currentImageCount = selectedMediaItems.filter(item => item.type === 'image').length;
            let addedCount = 0;
            let totalSizeMB = selectedMediaItems.reduce((sum, item) => sum + (item.file?.size || 0), 0) / 1024 / 1024;
            const allowedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif', 'image/bmp'];

            const readPromises = [];

            for (const file of files) {
                if (currentImageCount >= MAX_IMAGE_COUNT) {
                    alert(`You can select a maximum of ${MAX_IMAGE_COUNT} images.`);
                    break;
                }

                if (!allowedTypes.includes(file.type)) {
                    console.warn(`Skipping invalid file type: ${file.name} (${file.type})`);
                    continue;
                }

                const fileSizeMB = file.size / 1024 / 1024;
                if (fileSizeMB > MAX_IMAGE_SIZE_MB) {
                    alert(`Image "${file.name}" (${fileSizeMB.toFixed(1)}MB) is too large. Max ${MAX_IMAGE_SIZE_MB}MB per image.`);
                    continue;
                }

                if (totalSizeMB + fileSizeMB > MAX_TOTAL_IMAGE_SIZE_MB) {
                     alert(`Adding "${file.name}" would exceed the total image size limit of ${MAX_TOTAL_IMAGE_SIZE_MB}MB.`);
                     continue;
                }

                // Store the file object directly, read base64 later ONLY if needed for API call
                const mediaId = nextMediaId++;
                const newItem = {
                    id: mediaId,
                    type: 'image',
                    file: file, // Store the File object
                    base64: null, // Read later if needed
                    mimeType: file.type,
                    name: file.name
                };
                selectedMediaItems.push(newItem);
                currentImageCount++;
                totalSizeMB += fileSizeMB;
                addedCount++;
            }

             if (addedCount > 0) {
                 console.log(`Added ${addedCount} images. Total images: ${currentImageCount}`);
                 displayMediaPreview();
             }
             imageUploadInput.value = ''; // Reset input
        }

        // *** ADDED: Function to handle PDF file selection ***
        /**
         * Handles selection of one or more PDF files.
         * Checks for exclusivity with other media types.
         */
        function handlePdfFileSelect(event) {
            console.log("handlePdfFileSelect triggered");

            // Check for exclusivity: Cannot mix PDF with Image or Audio
            if (selectedMediaItems.length > 0 && selectedMediaItems.some(item => item.type === 'image' || item.type === 'audio')) {
                alert("Cannot select PDF(s) when image(s) or audio are already selected. Please remove other media first.");
                pdfUploadInput.value = ''; // Reset input
                return;
            }

            const files = event.target.files;
            if (!files || files.length === 0) {
                console.log("No PDF files selected or selection cancelled.");
                pdfUploadInput.value = '';
                return;
            }

            let currentPdfCount = selectedMediaItems.filter(item => item.type === 'pdf').length;
            let addedCount = 0;
            let totalSizeMB = selectedMediaItems.reduce((sum, item) => sum + (item.file?.size || 0), 0) / 1024 / 1024;

            for (const file of files) {
                if (currentPdfCount >= MAX_PDF_COUNT) {
                    alert(`You can select a maximum of ${MAX_PDF_COUNT} PDF files.`);
                    break; // Stop processing more files
                }

                // Validate type
                if (file.type !== 'application/pdf') {
                    console.warn(`Skipping non-PDF file: ${file.name} (${file.type})`);
                    continue; // Skip this file
                }

                // Validate size (client-side check)
                const fileSizeMB = file.size / 1024 / 1024;
                if (fileSizeMB > MAX_PDF_SIZE_MB) {
                    alert(`PDF "${file.name}" (${fileSizeMB.toFixed(1)}MB) is too large. Max ${MAX_PDF_SIZE_MB}MB per file (client check).`);
                    continue; // Skip this file
                }

                 // Store the file object directly for File API upload
                 const mediaId = nextMediaId++;
                 const newItem = {
                     id: mediaId,
                     type: 'pdf',
                     file: file, // Store the File object
                     name: file.name,
                     mimeType: file.type // Store mime type explicitly
                 };
                 selectedMediaItems.push(newItem);
                 currentPdfCount++;
                 totalSizeMB += fileSizeMB; // Accumulate total size for potential future checks
                 addedCount++;
            }

             if (addedCount > 0) {
                 console.log(`Added ${addedCount} PDFs. Total PDFs: ${currentPdfCount}`);
                 displayMediaPreview(); // Update the preview area
             }

             pdfUploadInput.value = ''; // Reset the input
        }


        /**
         * Handles selection of a single audio file. Ensures exclusivity.
         */
        function handleAudioFileSelect(event) {
            console.log("handleAudioFileSelect triggered");

             // *** MODIFIED: Check for PDF or image ***
            if (selectedMediaItems.length > 0 && selectedMediaItems.some(item => item.type === 'image' || item.type === 'pdf')) {
                alert("Cannot select audio when image(s) or PDF(s) are already selected. Please remove other media first.");
                audioUploadInput.value = ''; // Reset input
                return;
            }

            removeAllSelectedMedia(); // Clear any previous media

            const file = event.target.files[0];
            if (!file) {
                console.log("No audio file selected.");
                audioUploadInput.value = ''; // Reset input
                return;
            }

            if (!SUPPORTED_AUDIO_MIMES.includes(file.type)) {
                alert(`Unsupported audio file type: ${file.type}. Please select WAV, MP3, AIFF, AAC, OGG, or FLAC.`);
                audioUploadInput.value = ''; // Reset input
                return;
            }

            const fileSizeMB = file.size / 1024 / 1024;
            if (fileSizeMB > MAX_AUDIO_SIZE_MB) {
                alert(`Audio file too large (${fileSizeMB.toFixed(1)}MB). Max ${MAX_AUDIO_SIZE_MB}MB for upload.`);
                audioUploadInput.value = ''; // Reset input
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                 const mediaId = nextMediaId++;
                selectedMediaItems = [{ // Replace array with single audio item
                    id: mediaId,
                    type: 'audio',
                    file: file, // Store file object too
                    base64: e.target.result, // Store base64 for immediate use/preview
                    mimeType: file.type,
                    name: file.name
                }];
                console.log("Audio selected and read:", file.name, file.type, `(${fileSizeMB.toFixed(2)} MB)`);
                displayMediaPreview();
            }
            reader.onerror = (error) => {
                console.error("Error reading audio file:", error);
                alert("Error reading audio file.");
                removeAllSelectedMedia();
            };
            audioUploadInput.value = ''; // Reset input after starting read
            reader.readAsDataURL(file);
        }

        /**
         * Displays previews for all selected media items (Images, PDFs, Audio).
         * *** MODIFIED: Handles PDF items by showing filenames ***
         */
        function displayMediaPreview() {
            console.log("displayMediaPreview called. Items:", selectedMediaItems.length);
            // Clear existing previews
            imagePreviewsList.innerHTML = ''; // Clear image/pdf list area
            previewAudioContainer.style.display = 'none';
            previewAudio.removeAttribute('src');
            mediaPreviewInfo.textContent = ''; // Clear overall info text initially

            if (selectedMediaItems.length === 0) {
                mediaPreviewContainer.style.display = 'none';
                return;
            }

            const audioItem = selectedMediaItems.find(item => item.type === 'audio');
            const imageItems = selectedMediaItems.filter(item => item.type === 'image');
            const pdfItems = selectedMediaItems.filter(item => item.type === 'pdf');

            if (audioItem) {
                // Display single audio item
                imagePreviewsList.style.display = 'none';
                try {
                    previewAudio.src = audioItem.base64; // Use stored base64 for preview
                    previewAudio.load();
                    previewAudioContainer.style.display = 'flex';
                    mediaPreviewInfo.textContent = `1 audio file: ${audioItem.name || 'Audio preview'}`;
                    console.log("Showing audio preview for:", audioItem.name);
                } catch (e) {
                     console.error("Error setting audio src:", e);
                     previewAudioContainer.style.display = 'none';
                     mediaPreviewInfo.textContent = 'Error loading audio preview';
                }
            } else if (imageItems.length > 0) {
                // Display multiple image thumbnails
                previewAudioContainer.style.display = 'none';
                imagePreviewsList.style.display = 'flex';
                imageItems.forEach(item => {
                     // Read Base64 for preview on demand if not already read
                     if (!item.base64) {
                         // Note: This makes preview display slightly delayed for images, but avoids reading all upfront
                         const reader = new FileReader();
                         reader.onload = (e) => {
                             item.base64 = e.target.result; // Store it
                             renderImagePreviewItem(item); // Render now that base64 is available
                         };
                         reader.onerror = () => { item.base64 = '#error'; renderImagePreviewItem(item); }; // Mark as error
                         reader.readAsDataURL(item.file);
                     } else {
                         renderImagePreviewItem(item); // Render immediately if base64 exists
                     }
                });
                mediaPreviewInfo.textContent = `${imageItems.length} image(s) selected`;
                console.log("Showing", imageItems.length, "image previews.");
            } else if (pdfItems.length > 0) {
                 // *** ADDED: Display list of PDF filenames ***
                 previewAudioContainer.style.display = 'none'; // Hide audio player
                 imagePreviewsList.style.display = 'flex'; // Use the same container, but style items differently
                 imagePreviewsList.style.flexDirection = 'column'; // Stack PDFs vertically
                 imagePreviewsList.style.alignItems = 'stretch'; // Stretch items horizontally

                 pdfItems.forEach(item => {
                     try {
                         const itemContainer = document.createElement('div');
                         itemContainer.classList.add('pdf-preview-item');
                         itemContainer.dataset.mediaId = item.id;

                         const icon = document.createElement('span');
                         icon.textContent = '📄'; // PDF icon
                         icon.style.marginRight = '4px';

                         const nameSpan = document.createElement('span');
                         nameSpan.textContent = item.name || 'PDF File';
                         nameSpan.title = item.name || 'PDF File';

                         const removeBtn = document.createElement('button');
                         removeBtn.innerHTML = '&times;'; // Remove icon
                         removeBtn.title = `Remove ${item.name || 'PDF'}`;
                         removeBtn.onclick = (e) => { e.stopPropagation(); removeSelectedMediaItem(item.id); };

                         itemContainer.appendChild(icon);
                         itemContainer.appendChild(nameSpan);
                         itemContainer.appendChild(removeBtn);
                         imagePreviewsList.appendChild(itemContainer);
                     } catch (e) {
                          console.error("Error creating PDF preview element:", e);
                     }
                 });
                 mediaPreviewInfo.textContent = `${pdfItems.length} PDF file(s) selected`;
                 console.log("Showing", pdfItems.length, "PDF previews.");
            } else {
                 // Should not happen if selectedMediaItems is not empty
                 mediaPreviewContainer.style.display = 'none';
                 console.warn("displayMediaPreview called with empty or invalid items array.");
                 return;
            }

            mediaPreviewContainer.style.display = 'flex'; // Show the main preview container
        }

        /**
         * Helper to render a single image preview item.
         * Used by displayMediaPreview.
         */
        function renderImagePreviewItem(item) {
             try {
                 const existingItem = imagePreviewsList.querySelector(`[data-media-id="${item.id}"]`);
                 if (existingItem) return; // Avoid duplicates if called multiple times

                 const itemContainer = document.createElement('div');
                 itemContainer.classList.add('image-preview-item');
                 itemContainer.dataset.mediaId = item.id;

                 const img = document.createElement('img');
                 img.src = item.base64 === '#error' ? '' : (item.base64 || ''); // Use base64 if available
                 img.alt = item.base64 === '#error' ? 'Preview error' : (item.name || 'Image preview');
                 img.title = item.name || 'Image preview';
                 img.onerror = () => { img.alt = "Preview load error"; };

                 const removeBtn = document.createElement('button');
                 removeBtn.classList.add('remove-image-item-button');
                 removeBtn.innerHTML = '&times;';
                 removeBtn.title = `Remove ${item.name || 'image'}`;
                 removeBtn.onclick = (e) => { e.stopPropagation(); removeSelectedMediaItem(item.id); };

                 itemContainer.appendChild(img);
                 itemContainer.appendChild(removeBtn);
                 imagePreviewsList.appendChild(itemContainer);
             } catch (e) {
                  console.error("Error creating image preview element:", e);
             }
        }


        /**
         * Removes a specific media item by its ID.
         * @param {number} mediaId - The ID of the media item to remove.
         */
        function removeSelectedMediaItem(mediaId) {
             console.log(`Removing media item with ID: ${mediaId}`);
             selectedMediaItems = selectedMediaItems.filter(item => item.id !== mediaId);
             displayMediaPreview(); // Update the preview area
        }

        /**
         * Removes ALL currently selected media items and stops recording.
         */
        function removeAllSelectedMedia() {
            console.log("removeAllSelectedMedia called.");
            stopRecording(true); // Force stop recording if active

            selectedMediaItems = []; // Clear the array
            nextMediaId = 0; // Reset ID generator (optional)

            // Clear UI previews
            imagePreviewsList.innerHTML = '';
             imagePreviewsList.style.flexDirection = ''; // Reset flex direction
             imagePreviewsList.style.alignItems = ''; // Reset alignment
            previewAudio.removeAttribute('src');
            previewAudioContainer.style.display = 'none';
            mediaPreviewContainer.style.display = 'none';
            mediaPreviewInfo.textContent = '';

            // Reset file inputs
            imageUploadInput.value = '';
            pdfUploadInput.value = ''; // *** Reset PDF input ***
            audioUploadInput.value = '';

            console.log("All selected media removed.");
        }

        // --- Audio Recording Functions ---

        /**
         * Toggles audio recording on or off.
         */
        async function toggleRecording() {
            console.log("toggleRecording called. isRecording:", isRecording);
            if (isRecording) {
                stopRecording();
            } else {
                // *** MODIFIED: Prevent recording if images or PDFs are selected ***
                if (selectedMediaItems.some(item => item.type === 'image' || item.type === 'pdf')) {
                    alert("Cannot record audio when images or PDFs are selected. Please remove other media first.");
                    return;
                }
                // Check if app is busy before starting
                if (sendButton.disabled && !isRecording) {
                     const isDisabledByLoading = !currentUser || !API_KEY || !activeChatId || !genAI; // *** Check genAI ***
                     if (isDisabledByLoading) {
                         console.warn("Cannot start recording: App state prevents it (login/key/chat/sdk).");
                         return;
                     }
                     if (userInput.placeholder.includes("Generating") || userInput.placeholder.includes("Sending") || userInput.placeholder.includes("Uploading")) { // *** Added Uploading state ***
                          console.warn("Cannot start recording: App is currently busy.");
                          alert("Please wait for the current action to complete before recording.");
                          return;
                     }
                }
                await startRecording();
            }
        }

        /**
         * Starts audio recording. Ensures exclusivity with other media.
         */
        async function startRecording() {
            console.log("Attempting to start recording...");
            // Ensure no other media is selected BEFORE asking for permission
            if (selectedMediaItems.length > 0) {
                 alert("Cannot record audio when other media is selected. Please remove it first.");
                 return;
            }

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert("Audio recording is not supported by your browser.");
                console.error("getUserMedia not supported.");
                return;
            }

            try {
                console.log("Requesting microphone access...");
                 if (recorderStream) {
                    recorderStream.getTracks().forEach(track => track.stop());
                    recorderStream = null;
                    console.warn("Stopped lingering recorder stream before starting new one.");
                 }

                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                recorderStream = stream;
                console.log("Microphone access granted.");
                recordAudioButton.disabled = true; // Disable while initializing

                let options = {};
                const preferredMimeTypes = ['audio/ogg;codecs=opus', 'audio/webm;codecs=opus', 'audio/aac', 'audio/mp4'];
                for (const mimeType of preferredMimeTypes) {
                    if (MediaRecorder.isTypeSupported(mimeType)) {
                        options.mimeType = mimeType;
                        break;
                    }
                }
                 if (!options.mimeType) console.warn("No preferred MIME type supported, using browser default.");

                mediaRecorder = new MediaRecorder(stream, options);
                const actualMimeType = mediaRecorder.mimeType;
                console.log("Initializing MediaRecorder. Options:", options, "Actual MIME type:", actualMimeType);

                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) { audioChunks.push(event.data); }
                };

                mediaRecorder.onstop = () => {
                    console.log("MediaRecorder stopped. Chunks collected:", audioChunks.length);
                    if (recorderStream) {
                        recorderStream.getTracks().forEach(track => track.stop());
                        console.log("Microphone stream tracks stopped.");
                        recorderStream = null;
                    }

                    isRecording = false;
                    recordAudioButton.classList.remove('recording');
                    recordAudioButton.textContent = '🎙️'; recordAudioButton.title = 'Record audio';
                    recordingStatus.classList.remove('visible');
                    if (recordingTimerInterval) { clearInterval(recordingTimerInterval); recordingTimerInterval = null; }

                    if (audioChunks.length === 0) {
                        console.warn("No audio data recorded.");
                        setLoadingState(false); return;
                    }

                    const audioBlob = new Blob(audioChunks, { type: actualMimeType });
                    audioChunks = [];
                    const fileSizeMB = audioBlob.size / 1024 / 1024;
                    console.log(`Recording processing complete. Blob size: ${fileSizeMB.toFixed(3)} MB, Type: ${actualMimeType}`);

                    if (audioBlob.size === 0) {
                        console.warn("Created Blob has size 0."); alert("Recording failed: No audio data captured.");
                        setLoadingState(false); return;
                    }
                    if (fileSizeMB > MAX_AUDIO_SIZE_MB) {
                        alert(`Recorded audio too large (${fileSizeMB.toFixed(1)}MB). Max ${MAX_AUDIO_SIZE_MB}MB.`);
                        setLoadingState(false); return;
                    }

                    const reader = new FileReader();
                    reader.onloadend = () => {
                         if (reader.result && typeof reader.result === 'string' && reader.result.startsWith('data:')) {
                            console.log("Blob successfully converted to base64 Data URL.");
                            let finalMimeType = actualMimeType.split(';')[0];
                            const mediaId = nextMediaId++;
                            selectedMediaItems = [{ // Set as the only selected item
                                id: mediaId,
                                type: 'audio',
                                file: new File([audioBlob], `recording-${new Date().toISOString()}.audio`, { type: finalMimeType }), // Create a File object
                                base64: reader.result, // Store base64 for preview
                                mimeType: finalMimeType,
                                name: `recording-${new Date().toISOString().substring(0, 19).replace(/[:T]/g, '-')}.${finalMimeType.split('/')[1] || 'audio'}`
                            }];
                            displayMediaPreview();
                         } else {
                             console.error("FileReader finished but result is invalid or empty.");
                             alert("Error processing recorded audio (Invalid data URL).");
                         }
                         setLoadingState(false); // Enable UI after processing
                    };
                    reader.onerror = (error) => {
                         console.error("Error converting recorded audio blob to base64:", error);
                         alert("Error processing recorded audio.");
                         setLoadingState(false);
                    };
                    console.log("Reading Blob as Data URL...");
                    reader.readAsDataURL(audioBlob);
                };

                mediaRecorder.onerror = (event) => {
                    console.error("MediaRecorder error:", event.error || event);
                    alert(`Recording error: ${event.error?.name || 'Unknown recorder error'}`);
                    stopRecording(true);
                };

                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now();
                recordAudioButton.classList.add('recording');
                recordAudioButton.textContent = '🛑'; recordAudioButton.title = 'Stop recording';
                recordingStatus.classList.add('visible');
                recordingTimerSpan.textContent = '0s';
                setLoadingState(true, "Recording..."); // Disables other inputs

                recordingTimerInterval = setInterval(() => {
                    const elapsedSeconds = Math.floor((Date.now() - recordingStartTime) / 1000);
                    recordingTimerSpan.textContent = `${elapsedSeconds}s`;
                    if (elapsedSeconds >= RECORDING_TIME_LIMIT_SECONDS) {
                        console.log("Recording time limit reached.");
                        stopRecording(); alert(`Recording stopped automatically after ${RECORDING_TIME_LIMIT_SECONDS} seconds.`);
                    }
                }, 1000);

                console.log("Recording started...");
                recordAudioButton.disabled = false; // Ensure stop button is clickable

            } catch (error) {
                console.error("Error getting user media or starting recording:", error);
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    alert("Microphone access denied. Please allow microphone access in your browser settings and refresh.");
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                     alert("No microphone found. Please ensure a microphone is connected and enabled.");
                } else {
                    alert(`Could not start recording: ${error.name}`);
                }
                stopRecording(true);
            }
        }

        /**
         * Stops the audio recording if active.
         * @param {boolean} force - If true, bypasses some checks and forces UI reset.
         */
        function stopRecording(force = false) {
            console.log("stopRecording called. isRecording:", isRecording, "force:", force);
            if (mediaRecorder && (isRecording || force)) {
                try {
                    if (mediaRecorder.state === "recording" || mediaRecorder.state === "paused") {
                        mediaRecorder.stop();
                        console.log("MediaRecorder.stop() called.");
                    } else if (force) {
                         console.log("Recorder not active, but forcing cleanup.");
                         resetRecordingUI();
                    }
                } catch (error) {
                     console.error("Error calling mediaRecorder.stop():", error);
                     resetRecordingUI(); // Force UI reset on error
                }
            } else if (!force) {
                console.log("Not recording or recorder not available.");
            } else if (force) {
                 resetRecordingUI();
            }
        }

        /**
        * Helper function to reset recording related UI and state variables.
        */
        function resetRecordingUI() {
            console.log("Resetting recording UI and state.");
            isRecording = false;
            if (recordAudioButton) {
                recordAudioButton.classList.remove('recording');
                recordAudioButton.textContent = '🎙️';
                recordAudioButton.title = 'Record audio';
            }
            if (recordingStatus) recordingStatus.classList.remove('visible');
            if (recordingTimerInterval) {
                clearInterval(recordingTimerInterval);
                recordingTimerInterval = null;
            }
            if (recorderStream) {
                recorderStream.getTracks().forEach(track => track.stop());
                console.log("Microphone stream tracks stopped (reset UI).");
                recorderStream = null;
            }
            mediaRecorder = null;
            audioChunks = [];
            setLoadingState(false); // Ensure UI is generally enabled
        }


        // --- Chat Creation, Deletion, Switching ---
        // (No changes needed)
        async function createNewChat() {
            if (!currentUser) { displayError("Please log in."); return; }
            setLoadingState(true, "Creating chat...");
            removeAllSelectedMedia(); // Clear media on new chat
            const newChatRef = db.collection('chats').doc();
            const timestamp = firebase.firestore.FieldValue.serverTimestamp();
            try {
                await newChatRef.set({ userId: currentUser.uid, title: NEW_CHAT_TITLE, createdAt: timestamp, lastUpdated: timestamp });
                console.log("New chat created:", newChatRef.id);
            } catch (error) { console.error("Error creating new chat:", error); displayError("Failed to create chat."); setLoadingState(false); }
        }
        function handleChatListClick(event) {
             const target = event.target;
             const deleteButton = target.closest('.delete-chat-button');
             if (deleteButton) { event.stopPropagation(); const chatId = deleteButton.dataset.id; const chatListItem = deleteButton.closest('.chat-list-item'); const chatTitle = chatListItem?.textContent?.replace(deleteButton.textContent, '').trim() || 'this chat'; if (chatId) { confirmAndDeleteChat(chatId, chatTitle); } return; }
             const item = target.closest('.chat-list-item'); const clickedId = item?.dataset?.id; if (item && clickedId && clickedId !== activeChatId) { switchChat(clickedId); }
        }
        function confirmAndDeleteChat(chatId, chatTitle) { if (!currentUser || !chatId) return; if (confirm(`Delete chat "${chatTitle}" permanently?`)) { deleteChatFromFirestore(chatId); } else { console.log(`Deletion cancelled for chat: ${chatId}`); } }
        async function deleteChatFromFirestore(chatId) {
            if (!currentUser || !chatId) return; isDeletingChat = true; console.log(`[Delete Start] Chat: ${chatId}`); setLoadingState(true, "Deleting chat...");
            const chatDocRef = db.collection('chats').doc(chatId); const messagesRef = chatDocRef.collection('messages');
            try {
                const messagesSnapshot = await messagesRef.get(); if (!messagesSnapshot.empty) { const batch = db.batch(); messagesSnapshot.docs.forEach(doc => { batch.delete(doc.ref); }); await batch.commit(); console.log(`[Delete] Deleted ${messagesSnapshot.size} messages.`); }
                await chatDocRef.delete(); console.log(`[Delete Success] Chat doc: ${chatId}`);
                if (activeChatId === chatId) {
                    activeChatId = null; currentChatHistory = []; if (activeChatListener) { activeChatListener(); activeChatListener = null; } chatArea.innerHTML = ''; renderGreetingOrLoginPrompt();
                    userInput.placeholder = "Select or create chat";
                     // *** Disable media buttons ***
                    const enable = false;
                    sendButton.disabled = enable; mcqModeCheckbox.disabled = enable;
                    imageUploadButton.disabled = enable;
                    pdfUploadButton.disabled = enable; // *** PDF Button ***
                    audioUploadButton.disabled = enable; recordAudioButton.disabled = enable;
                    removeAllSelectedMedia();
                }
            } catch (error) { console.error(`[Delete Error] Chat ${chatId}:`, error); displayError(`Failed to delete chat.`); setLoadingState(false); }
            finally { setTimeout(() => { isDeletingChat = false; console.log(`[Delete End] Chat: ${chatId}`); }, 500); }
        }
        function switchChat(chatId) {
             if (!currentUser || !chatId || chatId === activeChatId) return; console.log("Switching to chat:", chatId); setLoadingState(true, "Loading chat..."); activeChatId = chatId;
             removeAllSelectedMedia(); highlightActiveChatInSidebar(); userInput.value = ''; autoGrowTextarea(); mcqModeCheckbox.checked = false; userInput.placeholder = "Loading messages...";
             // *** Disable media buttons while loading ***
             const enable = false;
             sendButton.disabled = enable; mcqModeCheckbox.disabled = enable;
             imageUploadButton.disabled = enable;
             pdfUploadButton.disabled = enable; // *** PDF Button ***
             audioUploadButton.disabled = enable; recordAudioButton.disabled = enable;
             loadAndListenForActiveChat(chatId);
        }

        // --- Message Loading (Firestore) ---
        // (Updated to enable media buttons correctly after load)
        function loadAndListenForActiveChat(chatId) {
            if (!currentUser || !chatId) { chatArea.innerHTML = ''; if (activeChatListener) { activeChatListener(); activeChatListener = null; } renderGreetingOrLoginPrompt(); setLoadingState(false);
                // *** Disable media buttons ***
                const enable = false;
                sendButton.disabled = enable; mcqModeCheckbox.disabled = enable;
                imageUploadButton.disabled = enable;
                pdfUploadButton.disabled = enable; // *** PDF Button ***
                audioUploadButton.disabled = enable; recordAudioButton.disabled = enable;
            return; }
            if (activeChatListener) { activeChatListener(); activeChatListener = null; }

            const messagesRef = db.collection('chats').doc(chatId).collection('messages').orderBy('timestamp', 'asc');
            chatArea.innerHTML = ''; const loadingMsg = displayMessage("Loading chat history...", 'ai', ['thinking']); scrollToBottom(true); console.log(`Listening for messages in chat ${chatId}`);

            activeChatListener = messagesRef.onSnapshot(snapshot => {
                console.log(`Received messages snapshot for chat ${chatId}:`, snapshot.size, "messages"); removeMessageElement(loadingMsg); chatArea.innerHTML = ''; currentChatHistory = [];

                if (snapshot.empty && activeChatId === chatId) {
                    const chatListItem = chatListContainer.querySelector(`.chat-list-item[data-id="${chatId}"]`); const chatTitle = chatListItem?.textContent?.replace(DELETE_ICON, '').trim() || '';
                    if (chatTitle && chatTitle !== NEW_CHAT_TITLE) { displayMessage("Chat empty. Send a message!", 'ai'); } else { renderGreetingOrLoginPrompt(); }
                } else {
                    snapshot.forEach(doc => {
                        const msgData = doc.data();
                        // Convert Firestore data to SDK history format
                        const role = msgData.role === 'user' ? 'user' : 'model';
                        const parts = [];
                        if (msgData.text) parts.push({ text: msgData.text });
                        // *** NOTE: History currently only includes text for API calls ***
                        // We are not re-fetching/re-uploading files from history for the API context
                        // The displayMessage function handles rendering media from Firestore data
                        currentChatHistory.push({ role: role, parts: parts });

                        // Display message using Firestore data (handles media rendering)
                        displayMessage(msgData.text || '', msgData.role, [], null, msgData);
                    });
                }
                scrollToBottom(true); setLoadingState(false);
                // *** Enable media buttons if chat active AND api key/sdk ready ***
                const enable = !!(API_KEY && genAI);
                sendButton.disabled = !enable; mcqModeCheckbox.disabled = !enable;
                imageUploadButton.disabled = !enable;
                pdfUploadButton.disabled = !enable; // *** PDF Button ***
                audioUploadButton.disabled = !enable; recordAudioButton.disabled = !enable;
                userInput.placeholder = "Enter prompt, attach media, or paste URL";
                 if (!isTestMode && !isReviewMode) { setTimeout(() => userInput.focus(), 100); }

            }, error => {
                console.error(`Error listening messages chat ${chatId}:`, error); displayError("Could not load messages."); removeMessageElement(loadingMsg); chatArea.innerHTML = ''; currentChatHistory = []; setLoadingState(false);
                // *** Disable media buttons on error ***
                 const enable = false;
                sendButton.disabled = enable; mcqModeCheckbox.disabled = enable;
                imageUploadButton.disabled = enable;
                pdfUploadButton.disabled = enable; // *** PDF Button ***
                audioUploadButton.disabled = enable; recordAudioButton.disabled = enable;
                userInput.placeholder = "Error loading chat";
            });
        }

        // --- File Upload Helper (Gemini File API) ---
        // *** ADDED: Function to upload and process a single file ***
        /**
         * Uploads a file to the Gemini File API and waits for it to be processed.
         * @param {File} file The file object to upload.
         * @param {number} index The index of the file (for logging).
         * @returns {Promise<object>} The processed file object from the API (contains uri, mimeType, etc.)
         * @throws {Error} If upload or processing fails.
         */
        async function uploadAndProcessFile(file, index) {
            if (!genAI) throw new Error("AI SDK not initialized.");
            console.log(`[File API] Uploading file ${index + 1}: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);
            setLoadingState(true, `Uploading file ${index + 1}/${selectedMediaItems.length}: ${file.name}...`);

            // 1. Upload the file
            const uploadResult = await genAI.uploadFile({
                file: file,
                mimeType: file.type, // Pass mime type explicitly
                displayName: file.name,
            });
            console.log(`[File API] Uploaded ${file.name}. API Name: ${uploadResult.file.name}, State: ${uploadResult.file.state}`);

            // 2. Poll for processing completion
            let fileResponse = await genAI.getFile(uploadResult.file.name);
            const startTime = Date.now();
            const timeoutMs = 120000; // 2 minutes timeout for processing

            while (fileResponse.file.state === 'PROCESSING') {
                 if (Date.now() - startTime > timeoutMs) {
                     throw new Error(`File processing timed out for ${file.name}.`);
                 }
                 setLoadingState(true, `Processing file ${index + 1}: ${file.name}...`);
                 console.log(`[File API] File ${file.name} state: ${fileResponse.file.state}. Waiting...`);
                 await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds before polling again
                 try {
                    fileResponse = await genAI.getFile(uploadResult.file.name);
                 } catch (pollError) {
                     console.error(`[File API] Error polling file ${uploadResult.file.name}:`, pollError);
                     // Decide how to handle polling errors, maybe retry a few times?
                     throw new Error(`Error checking processing status for ${file.name}.`);
                 }
            }

            // 3. Check final state
            if (fileResponse.file.state === 'FAILED') {
                console.error(`[File API] File processing failed for ${file.name}. Response:`, fileResponse);
                throw new Error(`File processing failed for ${file.name}. State: ${fileResponse.file.state}`);
            }

            if (fileResponse.file.state !== 'ACTIVE') {
                 console.warn(`[File API] File ${file.name} finished in unexpected state: ${fileResponse.file.state}. Response:`, fileResponse);
                  // You might want to handle other states like 'PAUSED' if applicable, or treat as failure
                 throw new Error(`File processing for ${file.name} resulted in state: ${fileResponse.file.state}.`);
            }

            console.log(`[File API] File ${file.name} processed successfully. URI: ${fileResponse.file.uri}`);
            return fileResponse.file; // Return the processed file object
        }

        // --- Message Sending (Gemini API & Firestore Save) ---
        // *** SIGNIFICANTLY MODIFIED: Uses SDK, Handles PDF Upload via File API ***
        async function handleSendMessage() {
            const userMessageTextRaw = userInput.value.trim();
            // Capture the current state of selected media items for this message
            const mediaItemsToSend = [...selectedMediaItems]; // Shallow copy

            console.log("handleSendMessage triggered. Text:", userMessageTextRaw, "Media items:", mediaItemsToSend.length);

            if (!API_KEY || !genAI) { displayError("API Key not set or AI SDK not initialized."); return; } // *** Check genAI ***
            if (!currentUser) { displayError("Please log in."); return; }
            if (!activeChatId) { displayError("Please select/create a chat."); return; }
            if (!userMessageTextRaw && mediaItemsToSend.length === 0) { console.log("Nothing to send."); return; }
            if (sendButton.disabled || isRecording) { console.log("Send button disabled or recording active."); return; }

            const isMCQRequest = mcqModeCheckbox.checked;
            setLoadingState(true, "Sending...");

            // Clear input and preview AFTER copying values
            userInput.value = ''; autoGrowTextarea();
            if (isMCQRequest) mcqModeCheckbox.checked = false;
            removeAllSelectedMedia(); // Clear preview & global state

            const timestamp = firebase.firestore.FieldValue.serverTimestamp();
            const messagesColRef = db.collection('chats').doc(activeChatId).collection('messages');
            const chatDocRef = db.collection('chats').doc(activeChatId);

            let isFirstUserMessageInNewChat = false;
            let potentialTestTitle = null;

            const youtubeMatch = userMessageTextRaw.match(youtubeRegex);
            const youtubeUrl = youtubeMatch ? youtubeMatch[0] : null;
            const youtubeVideoId = youtubeMatch ? youtubeMatch[1] : null;
            if (youtubeUrl) console.log("Detected YouTube URL:", youtubeUrl);

            // --- Prepare User Message Data for Firestore (Display Info) ---
            const userMsgData = { role: "user", text: userMessageTextRaw, timestamp: timestamp };
            if (youtubeVideoId) userMsgData.youtubeVideoId = youtubeVideoId;

            const singleAudioItem = mediaItemsToSend.find(item => item.type === 'audio');
            const imageItems = mediaItemsToSend.filter(item => item.type === 'image');
            const pdfItems = mediaItemsToSend.filter(item => item.type === 'pdf'); // *** Get PDF items ***

            if (singleAudioItem) {
                userMsgData.mediaType = 'audio';
                // Store base64 only for playback in UI, not needed for API call if using File API (but we use inline for audio)
                userMsgData.mediaData = singleAudioItem.base64;
                userMsgData.mediaMimeType = singleAudioItem.mimeType;
                userMsgData.mediaName = singleAudioItem.name;
            } else if (imageItems.length === 1) {
                userMsgData.mediaType = 'image';
                // Store base64 for single image display
                // Read Base64 if not already done
                if (!imageItems[0].base64) {
                    try {
                        imageItems[0].base64 = await readFileAsBase64(imageItems[0].file);
                    } catch (readError) { console.error("Error reading single image for Firestore:", readError); /* Maybe skip saving base64 */ }
                }
                userMsgData.mediaData = imageItems[0].base64;
                userMsgData.mediaMimeType = imageItems[0].mimeType;
                userMsgData.mediaName = imageItems[0].name;
            } else if (imageItems.length > 1) {
                userMsgData.mediaType = 'multi-image';
                userMsgData.mediaCount = imageItems.length;
                userMsgData.mediaNames = imageItems.map(img => img.name); // Store names
            } else if (pdfItems.length > 0) { // *** Handle PDFs for Firestore ***
                userMsgData.mediaType = 'multi-pdf'; // Use a distinct type
                userMsgData.mediaCount = pdfItems.length;
                userMsgData.mediaNames = pdfItems.map(pdf => pdf.name); // Store names
            }

            const loggableUserMsgData = { ...userMsgData };
            if (loggableUserMsgData.mediaData) loggableUserMsgData.mediaData = `[${loggableUserMsgData.mediaType} Base64 Data...]`;
            if (loggableUserMsgData.mediaNames) loggableUserMsgData.mediaNames = `[${loggableUserMsgData.mediaNames.length} files]`;
            console.log("Saving User Message to Firestore:", loggableUserMsgData);

             // --- Save User Message to Firestore ---
             try {
                 const chatSnap = await chatDocRef.get();
                 if (chatSnap.exists && chatSnap.data().title === NEW_CHAT_TITLE) { const messagesSnap = await messagesColRef.limit(1).get(); if (messagesSnap.empty) { isFirstUserMessageInNewChat = true; } }
                 await messagesColRef.add(userMsgData);
                 await chatDocRef.update({ lastUpdated: timestamp });
                 console.log("User message saved to Firestore.");
                 if (isFirstUserMessageInNewChat) {
                    let titleSource = userMessageTextRaw;
                    if (!titleSource) {
                        if (singleAudioItem) titleSource = "Audio Message";
                        else if (imageItems.length > 0) titleSource = imageItems.length > 1 ? "Multiple Images" : "Image Upload";
                        else if (pdfItems.length > 0) titleSource = pdfItems.length > 1 ? "Multiple PDFs" : "PDF Document"; // *** Title for PDFs ***
                        else titleSource = NEW_CHAT_TITLE;
                     }
                    const generatedTitle = generateChatTitle(titleSource); if (generatedTitle && generatedTitle !== NEW_CHAT_TITLE) { await updateActiveChatTitle(generatedTitle); console.log("Chat title updated:", generatedTitle); }
                 }
             } catch(error) { console.error("Error saving user message:", error); displayError("Failed to save message to database."); setLoadingState(false); return; }

             const thinking = displayMessage("Thinking...", 'ai', ['thinking']);
             scrollToBottom();

            // --- Prepare Parts for API Call using SDK ---
            const partsForApi = [];
            let userTextForPrompt = userMessageTextRaw;

            if (isMCQRequest) { // MCQ Prompt Modification
                 if (!userMessageTextRaw && mediaItemsToSend.length === 0) { displayError("Cannot generate MCQs without a text prompt or media."); removeMessageElement(thinking); setLoadingState(false); return; }
                 let baseTitle = userMessageTextRaw;
                 if (!baseTitle) {
                     if (singleAudioItem) baseTitle = "Audio Analysis";
                     else if (imageItems.length > 0) baseTitle = imageItems.length > 1 ? "Image Comparison" : "Image Analysis";
                     else if (pdfItems.length > 0) baseTitle = pdfItems.length > 1 ? "PDF Comparison" : "PDF Analysis"; // *** Title for PDFs ***
                     else baseTitle = "Generated Test";
                 }
                 potentialTestTitle = generateChatTitle(baseTitle) + ` (${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })})`;
                 const mcqInstructions = `\n\nPlease generate multiple choice questions based on the provided text and/or media (image(s)/PDF(s)/audio). Provide the response *only* as a valid JSON array string, enclosed within \`\`\`json ... \`\`\`. Each object in the array must have "question" (object with "en" and "ta" strings), "options" (array of 4 objects with "en" and "ta" strings), "answer" (string 'A', 'B', 'C', or 'D'), and "explanation" (object with "en" and "ta" strings). Provide accurate English content only. Do not include any text outside the JSON structure.`;
                 userTextForPrompt = userTextForPrompt ? userTextForPrompt + mcqInstructions : mcqInstructions;
                 console.log("MCQ mode: Modified text prompt for API, title:", potentialTestTitle);
             }

            if (userTextForPrompt) partsForApi.push({ text: userTextForPrompt });

            try { // Wrap media processing and API call in try/catch

                // Add Media Parts (Audio, Images, PDFs)
                if (singleAudioItem && singleAudioItem.base64 && singleAudioItem.mimeType) {
                     // For Audio, use inlineData (usually smaller)
                     const base64DataOnly = singleAudioItem.base64.substring(singleAudioItem.base64.indexOf(',') + 1);
                     if (base64DataOnly) {
                         partsForApi.push({ inlineData: { mimeType: singleAudioItem.mimeType, data: base64DataOnly } });
                         console.log(`Added audio inlineData: ${singleAudioItem.mimeType}`);
                     } else { console.error("Failed to extract base64 data from audio item."); }
                } else if (imageItems.length > 0) {
                    // For Images, use inlineData (check size limits implicitly handled by Gemini)
                    const imageBase64Promises = imageItems.map(item => {
                         if (!item.base64) { return readFileAsBase64(item.file); }
                         else { return Promise.resolve(item.base64); }
                     });
                     const imageBase64Results = await Promise.all(imageBase64Promises);

                    imageBase64Results.forEach((base64String, index) => {
                         if (base64String && typeof base64String === 'string') {
                             const base64DataOnly = base64String.substring(base64String.indexOf(',') + 1);
                             const mimeType = imageItems[index].mimeType;
                             if (base64DataOnly && mimeType) {
                                 partsForApi.push({ inlineData: { mimeType: mimeType, data: base64DataOnly } });
                             } else { console.error(`Failed to extract base64/mimeType for image: ${imageItems[index].name}`); }
                         } else { console.error(`Failed to read base64 for image: ${imageItems[index].name}`); }
                     });
                     console.log(`Added ${imageItems.length} images as inlineData.`);

                } else if (pdfItems.length > 0) {
                    // *** ADDED: Handle PDFs using File API ***
                    console.log(`Starting upload process for ${pdfItems.length} PDF(s)...`);
                    setLoadingState(true, `Uploading ${pdfItems.length} PDF(s)...`);

                    const uploadPromises = pdfItems.map((item, index) => uploadAndProcessFile(item.file, index));
                    const uploadedFiles = await Promise.all(uploadPromises); // Upload in parallel

                    // Create fileData parts from successfully uploaded files
                    const pdfParts = uploadedFiles.map(file => {
                         if (!file || !file.uri || !file.mimeType) {
                             console.error("Upload result missing URI or mimeType:", file);
                             throw new Error("Failed to get complete file details after upload.");
                         }
                         return { fileData: { mimeType: file.mimeType, fileUri: file.uri } };
                     });
                    partsForApi.push(...pdfParts);
                    console.log(`Added ${pdfParts.length} PDFs as fileData.`);
                }

                // Add YouTube URL if present (File API style part)
                if (youtubeUrl) {
                     // Note: Gemini documentation isn't explicit about YouTube URLs via File API structure.
                     // This assumes it might work like other file URIs. Test needed.
                     // If this doesn't work, YouTube handling might need separate logic or inline prompt text.
                     // partsForApi.push({ fileData: { mimeType: 'video/youtube', fileUri: youtubeUrl } }); // Hypothetical mime type
                     // Safer bet: Include URL in text prompt for now if File API doesn't support it directly.
                     console.warn("YouTube URL detected, but including it directly as fileData might not be supported. It's included in the text prompt.");
                }

                if (partsForApi.length === 0) {
                    console.warn("No valid parts (text or media) for API call.");
                    removeMessageElement(thinking);
                    setLoadingState(false);
                    return;
                }

                console.log("Calling Gemini API via SDK (Model:", MODEL_NAME, ")");
                setLoadingState(true, "Generating response...");

                // --- Call Gemini API using SDK ---
                const model = genAI.getGenerativeModel({
                     model: MODEL_NAME,
                     // Add safety settings if needed - matching the old fetch call
                     safetySettings: [ { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }, { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" }, { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }, { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }, ]
                });

                // Prepare history for SDK (needs to be in {role, parts} format)
                // currentChatHistory is already in this format
                const historyForSDK = currentChatHistory.filter(msg => msg.parts.length > 0); // Ensure no empty parts arrays

                // Construct the final request payload for the SDK
                const contentsRequest = [
                    ...historyForSDK, // Spread previous messages
                    { role: "user", parts: partsForApi } // Add current user message with all parts
                ];

                 console.log("SDK generateContent Request Payload:", JSON.stringify(contentsRequest, (key, value) => {
                    // Shorten data for logging
                    if (key === 'data' && typeof value === 'string' && value.length > 100) return value.substring(0, 50) + '...[truncated]';
                    return value;
                 }, 2));


                const result = await model.generateContent({ contents: contentsRequest });
                removeMessageElement(thinking);
                const response = result.response; // Use SDK's response object

                // --- Process API Response ---
                let aiMsgData = { role: "model", text: "Error: No valid response from API.", timestamp: firebase.firestore.FieldValue.serverTimestamp(), mcqData: null, mcqTitle: null };
                let displayAsError = true;
                let rawAiText = "";
                let blocked = false;

                // Check for blocking first (using SDK response structure)
                if (response.promptFeedback?.blockReason) {
                    aiMsgData.text = `Blocked (Prompt): ${response.promptFeedback.blockReason}`; blocked = true; displayAsError = true; console.warn("Prompt blocked:", response.promptFeedback.blockReason);
                } else if (response.candidates && response.candidates.length > 0) {
                    const candidate = response.candidates[0];
                    // Check candidate finish reason
                    if (candidate.finishReason === 'SAFETY') { aiMsgData.text = `Blocked (Response Safety): ${candidate.safetyRatings?.map(r => `${r.category.replace('HARM_CATEGORY_','')} (${r.probability})`).join(', ') || 'Reason unspecified'}`; blocked = true; displayAsError = true; console.warn("Response blocked due to safety:", candidate.safetyRatings); }
                    else if (candidate.finishReason === 'RECITATION') { aiMsgData.text = `Blocked (Response Recitation)`; blocked = true; displayAsError = true; console.warn("Response blocked due to recitation."); }
                    else if (candidate.content?.parts?.length > 0) {
                        // Extract text using SDK's helper function `response.text()`
                        try {
                             rawAiText = response.text(); // This aggregates text parts
                             aiMsgData.text = rawAiText; displayAsError = false;

                             if (isMCQRequest && !blocked) { // MCQ Parsing (remains the same logic)
                                 console.log("Attempting to parse MCQ JSON...");
                                 try {
                                     const jsonMatch = rawAiText.match(/```json\s*([\s\S]*?)\s*```/); const jsonString = jsonMatch ? jsonMatch[1].trim() : rawAiText.trim();
                                     if (jsonString.startsWith('[') && jsonString.endsWith(']')) {
                                         const mcqs = JSON.parse(jsonString);
                                         const isValidMCQArray = Array.isArray(mcqs) && mcqs.length > 0 && mcqs.every(q => q && typeof q.question?.en === 'string' && Array.isArray(q.options) && q.options.length === 4 && q.options.every(opt => opt && typeof opt.en === 'string') && typeof q.answer === 'string' && ['A','B','C','D'].includes(q.answer.toUpperCase()) && typeof q.explanation?.en === 'string' );
                                         if (isValidMCQArray) {
                                              mcqs.forEach(q => { if (!q.question.ta) q.question.ta = q.question.en; if (!q.explanation.ta) q.explanation.ta = q.explanation.en; q.options.forEach(opt => { if (!opt.ta) opt.ta = opt.en; }); });
                                              aiMsgData.text = `Generated ${mcqs.length} MCQs.`; aiMsgData.mcqData = mcqs; aiMsgData.mcqTitle = potentialTestTitle; console.log("MCQs parsed successfully:", mcqs.length); displayAsError = false;
                                         } else { console.warn("MCQ JSON validation failed."); aiMsgData.text = "MCQ format error (Invalid Structure).\n\n" + rawAiText; displayAsError = true; aiMsgData.mcqData = null; aiMsgData.mcqTitle = null; }
                                     } else { console.warn("MCQ response not JSON array."); aiMsgData.text = "Expected MCQ JSON format error (Not an Array).\n\n" + rawAiText; displayAsError = true; aiMsgData.mcqData = null; aiMsgData.mcqTitle = null; }
                                 } catch (parseError) { console.error("Failed to parse MCQ JSON:", parseError); aiMsgData.text = "Error parsing MCQ JSON.\n\n" + rawAiText; displayAsError = true; aiMsgData.mcqData = null; aiMsgData.mcqTitle = null; }
                             } // End MCQ parsing
                        } catch (textError) {
                            console.error("Error extracting text from SDK response:", textError);
                            aiMsgData.text = "Error: Could not extract text from AI response."; displayAsError = true;
                        }
                    } else if (candidate.finishReason === 'MAX_TOKENS') { console.warn("API response stopped due to MAX_TOKENS."); aiMsgData.text = rawAiText + "\n\n(Response may be truncated due to length limit)"; displayAsError = false; }
                    else if (candidate.finishReason === 'STOP') { console.warn("API response finished with STOP but no text part found."); aiMsgData.text = "(Model response finished without text)"; displayAsError = false; }
                    else { console.warn("Unexpected API finish reason:", candidate.finishReason); aiMsgData.text = `Sorry, received an unexpected response. (Reason: ${candidate.finishReason || 'Unknown'})`; displayAsError = true; }
                } else { console.error("API Error: No candidates found in SDK response."); aiMsgData.text = "Error: No response data received from API."; displayAsError = true; }


                 // --- Save AI Response to Firestore ---
                 try {
                      const loggableAiMsgData = { ...aiMsgData, ...(aiMsgData.mcqData && { mcqData: `[${aiMsgData.mcqData.length} MCQs]` }) };
                      console.log("Saving AI Response to Firestore:", loggableAiMsgData);
                      await messagesColRef.add(aiMsgData); await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() });
                      console.log("AI response/error saved to Firestore.");
                 } catch (saveError) { console.error("Error saving AI response:", saveError); displayError(`Failed to save response: ${aiMsgData.text}`); }

             } catch (error) { // Catch errors from media processing (e.g., upload) or SDK generateContent call
                 console.error("Error during media processing or API call:", error);
                 removeMessageElement(thinking);
                 const errorText = `Error: ${error.message || "An unexpected error occurred."}`;
                 displayError(errorText);
                 // Save the error message to Firestore
                 try {
                     await messagesColRef.add({ role: "model", text: errorText, timestamp: firebase.firestore.FieldValue.serverTimestamp() });
                     await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() });
                 } catch (saveError) { console.error("Failed to save error message:", saveError); }
             } finally {
                 setLoadingState(false);
                 if (!isTestMode && !isReviewMode && activeChatId) { setTimeout(() => userInput.focus(), 100); }
             }
        } // End of handleSendMessage


        // --- Chat Title Generation/Update ---
        // (No changes needed)
        function generateChatTitle(sourceText) { if (!sourceText || typeof sourceText !== 'string') return NEW_CHAT_TITLE; const text = sourceText.trim(); if (!text) return NEW_CHAT_TITLE; const title = text.split(/\s+/).slice(0, 5).join(' ').replace(/[.,!?;:]+$/, ''); return title.length > 35 ? title.substring(0, 32) + '...' : title; }
        async function updateActiveChatTitle(newTitle) { if (!currentUser || !activeChatId || !newTitle || typeof newTitle !== 'string' || !newTitle.trim() || newTitle.trim() === NEW_CHAT_TITLE) return; const finalTitle = newTitle.trim(); const chatDocRef = db.collection('chats').doc(activeChatId); try { await chatDocRef.update({ title: finalTitle }); console.log(`Chat ${activeChatId} title updated: "${finalTitle}"`); } catch (error) { console.error("Error updating chat title:", error); } }

        // --- File Reader Helper ---
        // *** ADDED: Helper to read file as Base64 ***
        function readFileAsBase64(file) {
             return new Promise((resolve, reject) => {
                 const reader = new FileReader();
                 reader.onload = () => resolve(reader.result);
                 reader.onerror = (error) => reject(error);
                 reader.readAsDataURL(file);
             });
        }

        // --- UI & Message Display Helpers ---
        // (Updated setLoadingState, displayMessage)
        function autoGrowTextarea() { userInput.style.height='auto'; userInput.style.height=(userInput.scrollHeight)+'px'; }
        function handleInputKeydown(event) { if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();handleSendMessage();} }
        function handleSuggestionClick(event) { if(event.target.classList.contains('suggestion-chip')){userInput.value=event.target.dataset.prompt||'';autoGrowTextarea();userInput.focus();} }
        function displayError(text) { console.error("Displaying Error:", text); displayMessage(`${text}`, 'ai', ['error-message']); scrollToBottom(); }
        function scrollToBottom(immediate = false) { chatArea.scrollTo({top:chatArea.scrollHeight,behavior:immediate?'auto':'smooth'}); }
        function removeMessageElement(element) { if(element && element.parentNode === chatArea) { chatArea.removeChild(element); } }

        /**
         * Updates UI elements based on loading state.
         * *** MODIFIED: Includes PDF button, checks genAI instance ***
         */
        function setLoadingState(isLoading, message = "Generating...") {
             // console.log(`setLoadingState: isLoading=${isLoading}, isRecording=${isRecording}`);
             const isAppDisabled = !currentUser || !API_KEY || !genAI; // *** Check genAI instance ***
             const isChatActive = !!activeChatId;

             // --- Calculate individual button states ---
             const isSidebarControlDisabled = isLoading || isAppDisabled || isRecording;
             userInput.disabled = isLoading || isAppDisabled || !isChatActive || isRecording;
             mcqModeCheckbox.disabled = isLoading || isAppDisabled || !isChatActive || isRecording;
             sendButton.disabled = isLoading || isAppDisabled || !isChatActive || isRecording;
             imageUploadButton.disabled = isLoading || isAppDisabled || !isChatActive || isRecording;
             pdfUploadButton.disabled = isLoading || isAppDisabled || !isChatActive || isRecording; // *** PDF Button ***
             audioUploadButton.disabled = isLoading || isAppDisabled || !isChatActive || isRecording;

             let recordButtonDisabled = isLoading || isAppDisabled || !isChatActive;
             if (isRecording) recordButtonDisabled = false; // ALWAYS allow clicking Stop
             recordAudioButton.disabled = recordButtonDisabled;

             startChatButton.disabled = isLoading || isAppDisabled || isRecording;
             testSearchInput.disabled = isLoading || isAppDisabled || isRecording;
             decreaseTextBtn.disabled = isSidebarControlDisabled || (currentUser && currentTextSizeMultiplier <= MIN_TEXT_SIZE_MULTIPLIER);
             increaseTextBtn.disabled = isSidebarControlDisabled || (currentUser && currentTextSizeMultiplier >= MAX_TEXT_SIZE_MULTIPLIER);
             themeToggleButton.disabled = isSidebarControlDisabled;

             // --- Update placeholder text (English Only) ---
             if (isRecording) { userInput.placeholder = "Recording audio..."; }
             else if (isLoading) { userInput.placeholder = message; }
             else if (isAppDisabled && !currentUser) { userInput.placeholder = "Please log in"; }
             else if (isAppDisabled && currentUser && (!API_KEY || !genAI)) { userInput.placeholder = "API Key missing or SDK init failed."; } // *** Updated message ***
             else if (!isChatActive) { userInput.placeholder = "Select or create a chat"; }
             else { userInput.placeholder = "Enter prompt, attach media, or paste URL"; }
        }

        function switchView(viewName, cameFromTests = false) { // (No changes needed)
            console.log("Switching view to:", viewName); chatView.classList.remove('active'); reviewView.classList.remove('active'); testView.classList.remove('active'); appContainer.classList.remove('hidden'); isTestMode = false; isReviewMode = false; cameFromAllTestsList = cameFromTests; saveReviewBtn.style.display = 'none'; exitReviewBtn.style.display = 'none';
            if(viewName === 'test'){ appContainer.classList.add('hidden'); testView.classList.add('active'); isTestMode = true; }
            else if(viewName === 'review'){ reviewView.classList.add('active'); isReviewMode = true; exitReviewBtn.style.display = 'inline-block'; exitReviewBtn.textContent = cameFromAllTestsList ? "Back to All Tests" : "Back to Chat"; }
            else { chatView.classList.add('active'); if (currentUser && activeChatId && API_KEY && genAI && !isRecording) { setTimeout(() => userInput.focus(), 100); } } // *** Check genAI ***
            if (viewName !== 'test' && testTimerInterval) { clearInterval(testTimerInterval); testTimerInterval = null; }
        }

        /**
         * Displays a message in the chat area. Handles text, formatting, media, etc.
         * *** MODIFIED: Displays indicator for multi-PDF messages ***
         */
        function displayMessage(text, sender, cssClasses = [], appendHtml = null, messageData = null) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', `${sender}-message`);
            if (cssClasses?.length > 0) messageElement.classList.add(...cssClasses);

            let hasContent = false;

            // 1. Display Media Indicator/Preview (from messageData)
            if (messageData?.mediaType === 'image' && messageData.mediaData) { // Single Image
                try { const img = document.createElement('img'); img.src = messageData.mediaData; img.alt = messageData.mediaName || "Uploaded Image"; img.classList.add('uploaded-image'); img.loading = "lazy"; img.onerror = () => { img.alt = "Image load error"; img.src = ""; }; messageElement.appendChild(img); hasContent = true; } catch (e) { console.error("Error creating image element:", e); }
            } else if (messageData?.mediaType === 'multi-image' && messageData.mediaCount > 0) { // Multi-Image Indicator
                try { const indicator = document.createElement('div'); indicator.classList.add('multi-media-indicator'); indicator.textContent = `(${messageData.mediaCount} image${messageData.mediaCount > 1 ? 's' : ''} sent: ${messageData.mediaNames?.join(', ') || ''})`; messageElement.appendChild(indicator); hasContent = true; } catch (e) { console.error("Error creating multi-image indicator:", e); }
            } else if (messageData?.mediaType === 'multi-pdf' && messageData.mediaCount > 0) { // *** Multi-PDF Indicator ***
                try { const indicator = document.createElement('div'); indicator.classList.add('multi-media-indicator'); indicator.textContent = `(${messageData.mediaCount} PDF${messageData.mediaCount > 1 ? 's' : ''} sent: ${messageData.mediaNames?.join(', ') || ''})`; messageElement.appendChild(indicator); hasContent = true; } catch (e) { console.error("Error creating multi-PDF indicator:", e); }
            } else if (messageData?.mediaType === 'audio' && messageData.mediaData) { // Audio
                try { const audioContainer = document.createElement('div'); audioContainer.classList.add('chat-audio-player'); const audioPlayer = document.createElement('audio'); audioPlayer.src = messageData.mediaData; audioPlayer.controls = true; audioPlayer.preload = "metadata"; if(messageData.mediaName) audioPlayer.title = messageData.mediaName; audioPlayer.onerror = () => { console.warn("Error loading audio player for src:", messageData.mediaData?.substring(0, 50)); audioContainer.innerHTML = `<span style='font-size:0.8em; color:var(--error-text);'>(Audio load error)</span>`; }; audioContainer.appendChild(audioPlayer); messageElement.appendChild(audioContainer); hasContent = true; } catch (e) { console.error("Error creating audio element:", e); }
            }

            // 2. Display Formatted Text Content
            if (text) {
                const messageContentContainer = document.createElement('div');
                try {
                    // Basic sanitization first (prevent direct HTML injection)
                    const tempDiv = document.createElement('div'); tempDiv.innerText = text; let formattedText = tempDiv.innerHTML;
                    // Apply formatting (markdown-like) - Order matters
                    if (messageData?.mediaType !== 'image') { // Avoid converting potential image URLs in image messages again
                         formattedText = formattedText.replace(imageUrlRegex, (match, imgUrl) => `<img src="${imgUrl}" class="chat-image" alt="Chat Image" loading="lazy" onerror="this.alt='Image URL load error'; this.src='';">`);
                    }
                    formattedText = formattedText.replace(/```([\s\S]*?)```/g, (match, code) => `<pre><code>${code.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code></pre>`).replace(/`([^`]+)`/g, (match, code) => `<code>${code.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code>`).replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/(?<!\*)\*(?!\*)(.*?)(?<!\*)\*(?!\*)/g, '<em>$1</em>').replace(/\n/g, '<br>');
                    messageContentContainer.innerHTML = formattedText; messageElement.appendChild(messageContentContainer); hasContent = true;
                    // Run MathJax if needed
                    if (text.includes('$') || text.includes('\\') || text.includes('^') || text.includes('_')) { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { setTimeout(() => { MathJax.typesetPromise([messageContentContainer]).catch(err => console.error('MathJax typesetting error:', err)); }, 50); } }
                } catch (e) { console.error("Error formatting text content:", e); }
            }

            // 3. YouTube Embed
            if (messageData?.youtubeVideoId) {
                 try { const youtubeEmbedDiv = document.createElement('div'); youtubeEmbedDiv.classList.add('youtube-embed-container'); const iframe = document.createElement('iframe'); iframe.classList.add('chat-video'); iframe.src = `https://www.youtube.com/embed/${messageData.youtubeVideoId}`; iframe.title = "YouTube video player"; iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"; iframe.allowFullscreen = true; iframe.loading = "lazy"; iframe.onerror = () => { youtubeEmbedDiv.innerHTML = `<span style='font-size:0.8em; color:var(--error-text);'>(YouTube embed error)</span>`; }; youtubeEmbedDiv.appendChild(iframe); messageElement.appendChild(youtubeEmbedDiv); hasContent = true; } catch (e) { console.error("Error creating YouTube embed:", e); }
            }

            // 4. MCQ Offer Button (AI only)
            if (messageData?.role === 'model' && messageData?.mcqData?.length > 0) {
                try { displayMCQOffer(messageData.mcqData, messageData.mcqTitle, messageElement); hasContent = true; } catch (e) { console.error("Error displaying MCQ offer:", e); }
            }
            // 5. Append Raw HTML (Use with caution)
            else if (appendHtml) {
                try { const appendDiv = document.createElement('div'); appendDiv.innerHTML = appendHtml; while (appendDiv.firstChild) { messageElement.appendChild(appendDiv.firstChild); } hasContent = true; } catch (e) { console.error("Error appending raw HTML:", e); }
            }

            if (hasContent || cssClasses.includes('thinking')) { chatArea.appendChild(messageElement); }
            else { console.warn(`Skipping display of empty message. Sender: ${sender}, Text: '${text}', Data:`, messageData); }
            return messageElement;
        }


        // --- MCQ/Test Specific Functions ---
        // (No changes needed)
         function handleChatAreaClick(event) {
            const startButton = event.target.closest('.start-test-button');
            if (startButton) {
                const mcqDataString = startButton.dataset.mcq; const titleFromButton = startButton.dataset.mcqTitle; let mcqs = null;
                if (mcqDataString) { try { mcqs = JSON.parse(mcqDataString); } catch (e) { console.error("Failed parse MCQ data from button:", e); displayError("Could not start test. Invalid data."); return; } }
                if (mcqs?.length > 0) { startMockTest(mcqs, titleFromButton || null); } else { displayError("MCQ data missing or invalid."); } return;
            }
            const clickedImage = event.target.closest('img.chat-image, img.uploaded-image');
            if (clickedImage?.src && !clickedImage.src.startsWith('#') && clickedImage.src.trim() !== '') {
                try { if (!clickedImage.src.startsWith('data:image') || clickedImage.src.length < 2 * 1024 * 1024) { window.open(clickedImage.src, '_blank'); } else { console.log("Clicked large base64 image in chat."); /* Maybe download instead */ } } catch (e) { console.error("Error opening image source:", e); }
            }
        }
        function displayMCQOffer(mcqData, mcqTitle, aiMessageElement) {
            if (aiMessageElement.querySelector('.start-test-button')) return;
            const questionCount = mcqData.length; const button = document.createElement('button'); button.classList.add('start-test-button'); button.textContent = `Start Mock Test (${questionCount} Qs)`; button.title = mcqTitle || `Start generated test`;
            try { button.dataset.mcq = JSON.stringify(mcqData); if (mcqTitle) { button.dataset.mcqTitle = mcqTitle; } } catch (e) { console.error("Failed stringify MCQ data for button:", e); return; }
            const buttonContainer = document.createElement('div'); buttonContainer.style.marginTop = '10px'; buttonContainer.appendChild(button); aiMessageElement.appendChild(buttonContainer);
        }
        function startMockTest(mcqs, title = null) { if (!currentUser) { displayError("Log in to start test."); return; } if (!mcqs?.length) { displayError("No questions for test."); if (cameFromAllTestsList) { switchView('chat'); } return; } console.log("Starting mock test:", mcqs.length, "Qs. Title:", title); currentTestMCQs = mcqs; currentQuestionIndex = 0; userAnswers = new Array(mcqs.length).fill(null); reviewResultsCache = null; switchView('test'); displayTestQuestion(0); startTestTimer(); const finalTitle = (title && title.trim()) ? title.trim() : `Mock Test (${mcqs.length} Qs)`; testTitle.textContent = finalTitle; }
        function displayTestQuestion(index) {
             if (index < 0 || index >= currentTestMCQs.length) return; currentQuestionIndex = index; const questionData = currentTestMCQs[index];
             const questionText = questionData.question?.en || "(Question missing)";
             testQuestionNumber.textContent = `Question ${index + 1}`; testQuestion.innerHTML = questionText; testOptionsContainer.innerHTML = ''; const options = questionData.options || []; const optionLetters = ['A', 'B', 'C', 'D'];
             options.forEach((optionObj, optionIndex) => {
                 if (optionIndex >= optionLetters.length) return;
                 const optionText = optionObj?.en || '(Option missing)';
                 const label = document.createElement('label'); const input = document.createElement('input'); input.type = 'radio'; input.name = `q_${index}`; input.value = optionIndex; input.checked = (userAnswers[index] === optionIndex); input.onchange = () => handleOptionSelect(optionIndex); label.appendChild(input); label.appendChild(document.createTextNode(` ${optionLetters[optionIndex]}. ${optionText}`)); testOptionsContainer.appendChild(label);
             });
             try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([testQuestion, testOptionsContainer]).catch(err=>console.error('MathJax Test Q Error:', err)); } } catch(e){ console.error("MathJax call failed in test:", e); }
             prevQuestionBtn.disabled = (index === 0); nextQuestionBtn.disabled = (index === currentTestMCQs.length - 1); questionCounter.textContent = `Q: ${index + 1} / ${currentTestMCQs.length}`;
        }
        function handleOptionSelect(optionIndex) { if (currentQuestionIndex >= 0 && currentQuestionIndex < userAnswers.length) { userAnswers[currentQuestionIndex] = optionIndex; console.log(`Answered Q${currentQuestionIndex + 1}: Option ${optionIndex}`); } }
        function handleTestNavigation(direction) { let newIndex = currentQuestionIndex; if (direction === 'prev' && currentQuestionIndex > 0) { newIndex--; } else if (direction === 'next' && currentQuestionIndex < currentTestMCQs.length - 1) { newIndex++; } if (newIndex !== currentQuestionIndex) { displayTestQuestion(newIndex); } }
        function startTestTimer() { if (testTimerInterval) clearInterval(testTimerInterval); testStartTime = Date.now(); testTimer.textContent = `Time: 00:00`; testTimerInterval = setInterval(() => { const elapsedSeconds = Math.floor((Date.now() - testStartTime) / 1000); const minutes = Math.floor(elapsedSeconds / 60).toString().padStart(2, '0'); const seconds = (elapsedSeconds % 60).toString().padStart(2, '0'); testTimer.textContent = `Time: ${minutes}:${seconds}`; }, 1000); }
        function submitTest() { if (!confirm("Submit test?")) return; if (testTimerInterval) clearInterval(testTimerInterval); const endTime = Date.now(); const timeTakenMs = testStartTime ? endTime - testStartTime : 0; const results = calculateResults(currentTestMCQs, userAnswers, timeTakenMs); reviewResultsCache = results; switchView('review', false); displayReview(results); }

        // --- Review Functions ---
        // (No changes needed)
        function calculateResults(mcqs, answers, timeMs) {
            let correctCount = 0, incorrectCount = 0, skippedCount = 0; const reviewQuestions = [];
            mcqs.forEach((q, idx) => {
                const uAIdx = answers[idx]; const opts = q.options || []; const cALtr = q.answer?.trim().toUpperCase(); const cAIdx = cALtr ? cALtr.charCodeAt(0) - 'A'.charCodeAt(0) : -1;
                const cATxtE = (cAIdx >= 0 && cAIdx < opts.length) ? (opts[cAIdx]?.en || '?') : "N/A";
                let uATxtE = "Skipped"; let st = "skipped";
                if (uAIdx !== null && uAIdx >= 0 && uAIdx < opts.length) { uATxtE = opts[uAIdx]?.en || '?'; if (uAIdx === cAIdx) { st = "correct"; correctCount++; } else { st = "incorrect"; incorrectCount++; } }
                else if (uAIdx !== null) { uATxtE = "Invalid"; st = "incorrect"; incorrectCount++; }
                else { skippedCount++; }
                reviewQuestions.push({ question: q.question?.en || '?', correctAnswer: cATxtE, userAnswer: uATxtE, status: st, explanation: q.explanation?.en || "N/A" });
            });
            const total = mcqs.length; const score = `${correctCount}/${total}`; const timeS = Math.round(timeMs / 1000); const mins = Math.floor(timeS / 60); const secs = timeS % 60; const timeStr = `${mins}m ${secs}s`;
            return { questions: reviewQuestions, summary: { score, correct: correctCount, incorrect: incorrectCount, skipped: skippedCount, timeString: timeStr }, testDate: new Date().toISOString(), timeTakenMs: timeMs, sourceChatId: activeChatId, testTitle: testTitle.textContent, originalMCQs: mcqs };
        }
        function displayReview(reviewData) {
            reviewContent.innerHTML = ''; reviewSummary.innerHTML = ''; reviewFilters.style.display = 'none';
            if (!reviewData?.questions?.length || !reviewData.summary || !reviewData.originalMCQs) { reviewSummary.innerHTML = "<span>No review data available.</span>"; saveReviewBtn.style.display = 'none'; return; }
            const { score, correct, incorrect, skipped, timeString } = reviewData.summary;
            reviewSummary.innerHTML = `<span>Score: ${score}</span> <span class="score-correct">Correct: ${correct}</span> <span class="score-incorrect">Incorrect: ${incorrect}</span> <span class="score-skipped">Skipped: ${skipped}</span> <span>Time: ${timeString}</span>`;
            reviewTitle.textContent = reviewData.testTitle || "Test Review";
            reviewData.questions.forEach((qSum, idx) => {
                const origQ = reviewData.originalMCQs[idx]; if (!origQ) return;
                const qTxt = origQ.question?.en || '?';
                const opts = origQ.options || []; const cALtr = origQ.answer?.trim().toUpperCase(); const cAIdx = cALtr ? cALtr.charCodeAt(0) - 'A'.charCodeAt(0) : -1;
                const cATxt = (cAIdx >= 0 && cAIdx < opts.length) ? (opts[cAIdx]?.en) : "N/A";
                let uATxt = qSum.userAnswer;
                const st = qSum.status;
                if (st === 'skipped') uATxt = "Skipped";
                else if (st === 'invalid') uATxt = "Invalid";
                const explTxt = origQ.explanation?.en || "N/A.";
                let iStCls = `status-${st}`; let aDtCls = `user-answer-${st}`;
                const rItem = document.createElement('div'); rItem.classList.add('review-item', iStCls); rItem.dataset.status = st;
                let dHtml = `<span class="${aDtCls}">Your Answer: ${uATxt}</span>`;
                if (st !== 'correct') { dHtml += `<br><span class="correct-answer">Correct Answer: ${cATxt}</span>`; }
                dHtml += `<div class="review-item-explanation">Explanation: ${explTxt}</div>`;
                rItem.innerHTML = `<div class="review-item-qnum">Q ${idx + 1}</div> <div class="review-item-question">${qTxt}</div> <div class="review-item-details">${dHtml}</div>`;
                reviewContent.appendChild(rItem);
            });
            if (incorrect > 0 || skipped > 0) reviewFilters.style.display = 'block'; else reviewFilters.style.display = 'none';
            if (reviewData.savedAt) { saveReviewBtn.textContent = "Saved"; saveReviewBtn.disabled = true; saveReviewBtn.style.display = 'inline-block'; }
            else if (reviewResultsCache && !cameFromAllTestsList) { saveReviewBtn.textContent = "Save Review"; saveReviewBtn.disabled = !currentUser; saveReviewBtn.style.display = 'inline-block'; }
            else { saveReviewBtn.style.display = 'none'; }
            filterReviewItems('all'); reviewFilters.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active-filter', btn.dataset.filter === 'all'); });
            try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([reviewContent]).catch(err=>console.error('MathJax Review Error:', err)); } } catch (e) { console.error("MathJax call failed in review:", e); }
        }
        function handleReviewFilterClick(event) { const button = event.target.closest('button[data-filter]'); if (button) { filterReviewItems(button.dataset.filter); } }
        function filterReviewItems(filter) { reviewFilters.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active-filter', btn.dataset.filter === filter); }); reviewContent.querySelectorAll('.review-item').forEach(item => { const show = (filter === 'all') || item.dataset.status === filter; item.classList.toggle('hidden-by-filter', !show); }); }
        function exitReview() { reviewResultsCache = null; switchView('chat'); reviewSummary.innerHTML = ''; reviewContent.innerHTML = ''; reviewTitle.textContent = 'Review'; }
        async function saveTestReviewToCloud() { if (!currentUser) { alert("Please log in to save the review."); return; } if (!reviewResultsCache || reviewResultsCache.savedAt) { alert("No new review data to save or already saved."); return; } if (!reviewResultsCache.originalMCQs?.length || !reviewResultsCache.summary) { if (!confirm("Warning: Review data seems incomplete. Save anyway?")) { return; } } const dataToSave = { ...reviewResultsCache, userId: currentUser.uid, savedAt: firebase.firestore.FieldValue.serverTimestamp(), }; saveReviewBtn.disabled = true; saveReviewBtn.textContent = "Saving..."; try { const newRef = await db.collection('testReviews').add(dataToSave); console.log("Review saved:", newRef.id); alert("Review saved!"); saveReviewBtn.textContent = "Saved"; if (reviewResultsCache) reviewResultsCache.savedAt = new Date(); } catch (error) { console.error("Error saving review:", error); alert("Failed to save review."); saveReviewBtn.disabled = false; saveReviewBtn.textContent = "Save Review"; } }


        // --- All Tests List Functions ---
        // (No changes needed)
        function loadAndListenForTests(userId) { if (testListListener) { testListListener(); testListListener = null; } const testsRef = db.collection('testReviews').where('userId', '==', userId).orderBy('savedAt', 'desc'); console.log(`Listening for saved tests for user ${userId}`); testListListener = testsRef.onSnapshot(snapshot => { allSavedTestsData = []; snapshot.forEach(doc => { allSavedTestsData.push({ id: doc.id, ...doc.data() }); }); console.log("Received saved tests snapshot:", allSavedTestsData.length, "tests"); renderAllTestsList(allSavedTestsData); filterTestsInSidebar(); }, error => { console.error("Error listening for saved tests:", error); allTestsListContainer.innerHTML = `<div style="padding:10px; color:var(--error-text);">Error loading saved tests.</div>`; allSavedTestsData = []; }); }
        function renderAllTestsList(tests) { allTestsListContainer.innerHTML = ''; if (!currentUser) { allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">Login to see tests.</div>'; return; } if (tests.length === 0) { allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">No saved tests found.</div>'; } else { tests.forEach(testData => { const item = document.createElement('div'); item.classList.add('test-list-item'); item.dataset.reviewId = testData.id; const title = testData.testTitle || '(Untitled Test)'; const date = testData.savedAt?.toDate ? testData.savedAt.toDate().toLocaleString() : 'Unknown date'; const score = testData.summary?.score || 'N/A'; const hasReattemptData = testData.originalMCQs?.length > 0 && testData.originalMCQs.every(q => q?.question && q.options && q.answer && q.explanation); const infoDiv = document.createElement('div'); infoDiv.classList.add('test-item-info'); const titleSpan = document.createElement('span'); titleSpan.classList.add('test-item-title'); titleSpan.textContent = title; titleSpan.title = title; const detailSpan = document.createElement('span'); detailSpan.classList.add('test-item-details'); detailSpan.textContent = `Saved: ${date} | Score: ${score}`; const controlsDiv = document.createElement('div'); controlsDiv.classList.add('test-item-controls'); const editButton = document.createElement('button'); editButton.innerHTML = EDIT_TEST_ICON; editButton.title = "Edit title"; editButton.dataset.action = "edit-title"; controlsDiv.appendChild(editButton); const deleteButton = document.createElement('button'); deleteButton.innerHTML = DELETE_TEST_ICON; deleteButton.title = "Delete test"; deleteButton.dataset.action = "delete-test"; controlsDiv.appendChild(deleteButton); infoDiv.appendChild(titleSpan); infoDiv.appendChild(detailSpan); infoDiv.appendChild(controlsDiv); const actionsDiv = document.createElement('div'); actionsDiv.classList.add('test-item-actions'); const viewButton = document.createElement('button'); viewButton.textContent = "Details"; viewButton.dataset.action = "view"; actionsDiv.appendChild(viewButton); const reattemptSelect = document.createElement('select'); reattemptSelect.dataset.action = "reattempt"; reattemptSelect.disabled = !hasReattemptData; reattemptSelect.title = hasReattemptData ? "Reattempt test" : "Reattempt data not available"; reattemptSelect.innerHTML = `<option value="" selected>${hasReattemptData ? 'Reattempt...' : 'N/A'}</option> <option value="mistaked" ${!hasReattemptData?'disabled':''}>Mistaked Only</option> <option value="skipped" ${!hasReattemptData?'disabled':''}>Skipped Only</option> <option value="both" ${!hasReattemptData?'disabled':''}>Mistaked/Skipped</option> <option value="full" ${!hasReattemptData?'disabled':''}>Full Test</option>`; reattemptSelect.addEventListener('change', (e) => { const selectedMode = e.target.value; if (selectedMode) { const reviewId = e.target.closest('.test-list-item')?.dataset.reviewId; if (reviewId) { startReattempt(reviewId, selectedMode); } e.target.value = ""; } }); actionsDiv.appendChild(reattemptSelect); item.appendChild(infoDiv); item.appendChild(actionsDiv); allTestsListContainer.appendChild(item); }); } }
        function filterTestsInSidebar() { const searchTerm = testSearchInput.value.toLowerCase().trim(); const items = allTestsListContainer.querySelectorAll('.test-list-item'); let visibleCount = 0; const noResultsMsg = allTestsListContainer.querySelector('.no-search-results'); if (noResultsMsg) { noResultsMsg.remove(); } items.forEach(item => { const title = item.querySelector('.test-item-title')?.textContent.toLowerCase() || ''; const details = item.querySelector('.test-item-details')?.textContent.toLowerCase() || ''; const isMatch = title.includes(searchTerm) || details.includes(searchTerm); item.classList.toggle('hidden-by-search', !isMatch); if (isMatch) visibleCount++; }); if (visibleCount === 0 && searchTerm !== '' && items.length > 0) { const msgDiv = document.createElement('div'); msgDiv.textContent = "No saved tests match your search."; msgDiv.classList.add('no-search-results'); allTestsListContainer.appendChild(msgDiv); } }
        async function handleAllTestsListClick(event) { const button = event.target.closest('button[data-action]'); if (!button) return; const action = button.dataset.action; const listItem = button.closest('.test-list-item'); const reviewId = listItem?.dataset.reviewId; if (!reviewId) { console.error("Could not find review ID for action:", action); return; } switch (action) { case "view": const reviewData = allSavedTestsData.find(t => t.id === reviewId); if (reviewData) { reviewResultsCache = reviewData; switchView('review', true); displayReview(reviewData); } else { alert("Error: Could not find review data to display."); } break; case "edit-title": enterTestTitleEditMode(listItem, reviewId); break; case "delete-test": const testTitle = listItem.querySelector('.test-item-title')?.textContent || 'this test'; if (confirm(`Are you sure you want to delete the test "${testTitle}"?`)) { deleteSavedTest(reviewId, listItem); } break; } }
        function enterTestTitleEditMode(listItem, reviewId) { const infoDiv = listItem.querySelector('.test-item-info'); const titleSpan = infoDiv.querySelector('.test-item-title'); const detailSpan = infoDiv.querySelector('.test-item-details'); const controlsDiv = infoDiv.querySelector('.test-item-controls'); const currentTitle = titleSpan.textContent; titleSpan.style.display = 'none'; detailSpan.style.display = 'none'; if(controlsDiv) controlsDiv.style.display = 'none'; if (infoDiv.querySelector('.test-item-edit-mode')) return; const editContainer = document.createElement('div'); editContainer.classList.add('test-item-edit-mode'); const input = document.createElement('input'); input.type = 'text'; input.value = currentTitle; input.maxLength = 100; input.addEventListener('keydown', (e) => { if (e.key === 'Enter') { saveTestTitle(listItem, reviewId, input.value); } else if (e.key === 'Escape') { exitTestTitleEditMode(listItem, currentTitle); } }); const saveButton = document.createElement('button'); saveButton.textContent = 'Save'; saveButton.onclick = () => saveTestTitle(listItem, reviewId, input.value); const cancelButton = document.createElement('button'); cancelButton.textContent = 'Cancel'; cancelButton.onclick = () => exitTestTitleEditMode(listItem, currentTitle); editContainer.appendChild(input); editContainer.appendChild(saveButton); editContainer.appendChild(cancelButton); infoDiv.appendChild(editContainer); input.focus(); input.select(); }
        function exitTestTitleEditMode(listItem, originalTitle = null) { const infoDiv = listItem.querySelector('.test-item-info'); const titleSpan = infoDiv.querySelector('.test-item-title'); const detailSpan = infoDiv.querySelector('.test-item-details'); const controlsDiv = infoDiv.querySelector('.test-item-controls'); const editContainer = infoDiv.querySelector('.test-item-edit-mode'); if (editContainer) editContainer.remove(); if (originalTitle !== null && titleSpan) { titleSpan.textContent = originalTitle; titleSpan.title = originalTitle; } if(titleSpan) titleSpan.style.display = ''; if(detailSpan) detailSpan.style.display = ''; if(controlsDiv) controlsDiv.style.display = ''; } // Fixed potential typo cD -> controlsDiv
        async function saveTestTitle(listItem, reviewId, newTitle) { const trimmedTitle = newTitle.trim(); if (!trimmedTitle) { alert("Test title cannot be empty."); return; } if (trimmedTitle.length > 100) { alert("Test title is too long (max 100 characters)."); return; } const docRef = db.collection('testReviews').doc(reviewId); try { await docRef.update({ testTitle: trimmedTitle }); console.log("Test title updated successfully:", reviewId); const titleSpan = listItem.querySelector('.test-item-title'); if (titleSpan) { titleSpan.textContent = trimmedTitle; titleSpan.title = trimmedTitle; } const testIndex = allSavedTestsData.findIndex(t => t.id === reviewId); if (testIndex > -1) allSavedTestsData[testIndex].testTitle = trimmedTitle; exitTestTitleEditMode(listItem); } catch (error) { console.error("Error updating test title:", error); alert("Failed to update test title."); } }
        async function deleteSavedTest(reviewId, listItem) { if (!currentUser || !reviewId) return; listItem.style.opacity = '0.5'; listItem.style.pointerEvents = 'none'; const docRef = db.collection('testReviews').doc(reviewId); try { await docRef.delete(); console.log("Saved test deleted successfully:", reviewId); allSavedTestsData = allSavedTestsData.filter(t => t.id !== reviewId); alert("Saved test deleted."); } catch (error) { console.error("Error deleting saved test:", error); alert("Failed to delete saved test."); listItem.style.opacity = '1'; listItem.style.pointerEvents = 'auto'; } }
        async function startReattempt(reviewId, mode) { console.log(`Attempting reattempt for review ID: ${reviewId}, Mode: ${mode}`); const reviewData = allSavedTestsData.find(t => t.id === reviewId); if (!reviewData) { alert("Error: Could not find the saved review data for reattempt."); return; } const originalMCQs = reviewData.originalMCQs; const hasValidData = originalMCQs?.length > 0 && originalMCQs.every(q => q?.question && q.options && q.answer && q.explanation); if (!hasValidData) { alert("Error: Cannot reattempt. Original test data is missing or invalid."); return; } const summaryQuestions = reviewData.questions || []; let questionsForReattempt = []; switch (mode) { case 'mistaked': questionsForReattempt = originalMCQs.filter((mcq, index) => summaryQuestions[index]?.status === 'incorrect'); break; case 'skipped': questionsForReattempt = originalMCQs.filter((mcq, index) => summaryQuestions[index]?.status === 'skipped'); break; case 'both': questionsForReattempt = originalMCQs.filter((mcq, index) => summaryQuestions[index]?.status === 'incorrect' || summaryQuestions[index]?.status === 'skipped'); break; case 'full': default: questionsForReattempt = [...originalMCQs]; break; } if (questionsForReattempt.length === 0) { alert(`No questions found for the selected reattempt mode ('${mode}').`); return; } const originalTitle = reviewData.testTitle || 'Test'; const reattemptTitle = `${originalTitle} (Reattempt: ${mode})`; startMockTest(questionsForReattempt, reattemptTitle); }

    </script>

</body>
</html>
