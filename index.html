<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Version Updated -->
    <title>Gemini Chat + Mock Test (v9.9 - File API Fix)</title>
    <script>
        // MathJax Configuration
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
            svg: { fontCache: 'global' },
            options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <!-- <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script> -->

    <!-- Google Generative AI SDK (Loaded as Module) -->
    <script type="module">
        // Make SDK accessible globally after import
        try {
            // *** Using await import for clarity ***
            const { GoogleGenerativeAI } = await import("https://esm.run/@google/generative-ai");
            window.GoogleGenerativeAI = GoogleGenerativeAI;
            console.log("GoogleGenerativeAI SDK loaded successfully via module.");
            // Optionally trigger an event or set a flag if needed by non-module script
            window.dispatchEvent(new Event('google-ai-sdk-loaded'));
        } catch (error) {
            console.error("Failed to load GoogleGenerativeAI SDK:", error);
            // Display error to user?
            window.googleAiSdkLoadError = error; // Store error globally if needed
        }
    </script>

    <style>
        /* --- Styles (v9.9 - No CSS changes from 9.8) --- */
        :root { /* ... Theme Variables ... */
             --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --sidebar-width: 260px; --message-font-size-base: 1rem;
            /* LIGHT */ --sidebar-bg: #f7f7f7; --main-bg: #ffffff; --input-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #2c2c2c; --text-secondary: #5f5f5f; --text-placeholder: #999999; --accent-color: #d97a7a; --user-message-bg: #cce0ff; --user-message-text: #1c1c1c; --ai-message-bg: #f0f0f0; --ai-message-text: #2c2c2c; --button-bg: #f0f0f0; --button-hover-bg: #e0e0e0; --active-item-bg: #e0e0e0; --code-bg: #e8e8e8; --scrollbar-thumb: #ccc; --scrollbar-thumb-hover: #bbb; --app-outer-bg: #e8e8e8; --send-button-bg: var(--accent-color); --send-button-hover-bg: #c76b6b; --send-button-text: #ffffff; --error-bg: #ffebee; --error-text: #c62828; --error-border: #ef9a9a; --message-font-size: var(--message-font-size-base); --delete-button-color: #aaa; --delete-button-hover-color: #dc3545; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color); --preview-bg: var(--button-bg); --preview-border: var(--border-color); --remove-btn-color: var(--text-secondary); --remove-btn-hover-color: var(--error-text);
            /* Audio Specific */
            --record-button-bg: #ff6b6b; --record-button-text: #ffffff; --stop-button-bg: #4a4a4a; --stop-button-text: #ffffff;
        }
        body.dark-theme { /* DARK */ --sidebar-bg: #2a2a2e; --main-bg: #1e1e1e; --input-bg: #2a2a2e; --border-color: #404040; --text-primary: #e0e0e0; --text-secondary: #a0a0a0; --text-placeholder: #777777; --accent-color: #e58b8b; --user-message-bg: #3a4a6b; --user-message-text: #e8e8e8; --ai-message-bg: #333333; --ai-message-text: #e0e0e0; --button-bg: #404040; --button-hover-bg: #505050; --active-item-bg: #454545; --code-bg: #2c2c2e; --scrollbar-thumb: #555; --scrollbar-thumb-hover: #666; --app-outer-bg: #121212; --send-button-bg: var(--accent-color); --send-button-hover-bg: #f09f9f; --send-button-text: #1e1e1e; --error-bg: #5c2b2b; --error-text: #ffcdd2; --error-border: #8c4343; --delete-button-color: #666; --delete-button-hover-color: #f09f9f; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color); --preview-bg: var(--button-bg); --preview-border: var(--border-color); --remove-btn-color: var(--text-secondary); --remove-btn-hover-color: var(--error-text);
            /* Audio Specific */
             --record-button-bg: #ff8787; --record-button-text: #1e1e1e; --stop-button-bg: #777777; --stop-button-text: #e0e0e0;
        }
        body { font-family: var(--font-family); margin: 0; padding: 0; background-color: var(--app-outer-bg); color: var(--text-primary); font-size: 15px; transition: background-color 0.3s ease, color 0.3s ease; }

        /* Layout & Structure */
        .app-container { display: flex; height: 100vh; width: 100vw; overflow: hidden; } .app-container.hidden { display: none; }
        .sidebar { width: var(--sidebar-width); background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; padding: 15px 0; box-sizing: border-box; flex-shrink: 0; transition: background-color 0.3s ease, border-color 0.3s ease, width 0.3s ease; }
        .main-container { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; overflow: hidden; position: relative; }
        .main-content, .review-view { display: none; flex-direction: column; background-color: var(--main-bg); height: 100%; width: 100%; overflow: hidden; transition: background-color 0.3s ease; }
        .main-content.active, .review-view.active { display: flex; }
        .chat-area { flex-grow: 1; overflow-y: auto; padding: 30px 10% 20px; display: flex; flex-direction: column; max-width: 800px; margin: 0 auto; width: 80%; }
        .input-container { padding: 15px 10% 20px; border-top: 1px solid var(--border-color); background-color: var(--input-bg); max-width: 800px; margin: 0 auto; width: 80%; transition: background-color 0.3s ease, border-color 0.3s ease; display: none; }

        /* Sidebar Elements */
         .sidebar-header { padding: 10px 20px; font-size: 1.1em; font-weight: 600; color: var(--text-primary); }
         .sidebar-section { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; margin-top: 10px; }
         .sidebar-section-title { padding: 5px 20px; font-size: 0.85em; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; flex-shrink: 0; }
         #all-tests-section { border-bottom: 1px solid var(--border-color); margin-bottom: 10px; padding-bottom: 10px; flex-shrink: 0; display: flex; flex-direction: column; max-height: 40%; display: none; }
         #all-tests-section.visible { display: flex; }
         #test-search-input { width: calc(100% - 40px); padding: 8px 10px; margin: 5px 15px 10px 15px; border: 1px solid var(--input-border-color); background-color: var(--input-bg); color: var(--text-primary); border-radius: 6px; font-size: 0.9em; box-sizing: border-box; }
         #test-search-input:focus { outline: none; border-color: var(--input-focus-border-color); }
         #all-tests-list { overflow-y: auto; padding: 0 15px; flex-grow: 1; }
         #all-tests-list::-webkit-scrollbar { width: 6px; } #all-tests-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} #all-tests-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .test-list-item { padding: 8px 10px; margin-bottom: 5px; border-radius: 6px; background-color: var(--button-bg); cursor: default; transition: background-color 0.2s ease; display: flex; flex-direction: column; gap: 5px; border: 1px solid var(--border-color); }
         .test-list-item.hidden-by-search { display: none; }
         .test-list-item .no-search-results { padding:10px;color:var(--text-secondary);font-size:0.9em; }
         .test-item-info { font-size: 0.9em; color: var(--text-primary); position: relative; padding-right: 50px; }
         .test-item-title { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; }
         .test-item-details { font-size: 0.8em; color: var(--text-secondary); }
         .test-item-actions { display: flex; justify-content: flex-start; gap: 8px; margin-top: 5px; }
         .test-item-actions button, .test-item-actions select { background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 4px 8px; font-size: 0.8em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease; }
         .test-item-actions button:hover, .test-item-actions select:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .test-item-actions select:disabled { opacity: 0.6; cursor: not-allowed; }
        .test-item-controls { position: absolute; right: 5px; top: 0; display: flex; gap: 5px; }
        .test-item-controls button { background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.1em; padding: 0 3px; line-height: 1; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
        .test-item-controls button:hover { opacity: 1; color: var(--delete-button-hover-color); }
        .test-item-edit-mode { display: flex; align-items: center; }
        .test-item-edit-mode input[type="text"] { flex-grow: 1; padding: 2px 4px; margin-right: 5px; border: 1px solid var(--input-focus-border-color); background-color: var(--input-bg); color: var(--text-primary); border-radius: 3px; font-size: 0.95em; }
        .test-item-edit-mode button { font-size: 0.9em; padding: 2px 5px; background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 3px; cursor: pointer; margin-left: 3px; }
        .test-item-edit-mode button:hover { background-color: var(--button-hover-bg); }
         .start-chat-button { display: flex; align-items: center; gap: 8px; background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; padding: 10px 15px; margin: 0 15px 10px 15px; font-size: 0.95em; font-weight: 500; cursor: pointer; text-align: left; transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease; flex-shrink: 0; }
         .start-chat-button:hover { background-color: var(--button-hover-bg); } .start-chat-button svg { fill: currentColor; width: 16px; height: 16px; }
         .start-chat-button:disabled { opacity: 0.6; cursor: not-allowed; }
         .chat-list { overflow-y: auto; padding: 0 15px; margin-bottom: 10px; flex-grow: 1; }
         .chat-list::-webkit-scrollbar { width: 6px; } .chat-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} .chat-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .chat-list-item { padding: 8px 30px 8px 10px; margin-bottom: 4px; border-radius: 6px; font-size: 0.9em; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-secondary); transition: background-color 0.2s ease, color 0.2s ease; position: relative; }
         .chat-list-item:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .chat-list-item.active { background-color: var(--active-item-bg); color: var(--text-primary); font-weight: 500; }
         .delete-chat-button { position: absolute; right: 6px; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.3em; line-height: 1; padding: 0; display: none; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
         .chat-list-item:hover .delete-chat-button { display: block; }
         .delete-chat-button:hover { color: var(--delete-button-hover-color); opacity: 1; }
         .sidebar-footer { border-top: 1px solid var(--border-color); padding: 10px 15px; transition: border-color 0.3s ease; flex-shrink: 0; }
         .sidebar-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
         .text-size-controls span, .theme-toggle span { font-size: 0.85em; color: var(--text-secondary); }
         .text-size-buttons button, .theme-toggle button { background: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 2px 8px; margin-left: 5px; cursor: pointer; font-size: 1.1em; line-height: 1; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
         .text-size-buttons button:hover, .theme-toggle button:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .text-size-buttons button:disabled, .theme-toggle button:disabled { opacity: 0.6; cursor: not-allowed; }
         .account-info { display: flex; align-items: center; gap: 10px; font-size: 0.9em; margin-top: 10px; }
         .account-avatar { width: 30px; height: 30px; border-radius: 50%; background-color: #6c757d; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; }
         .account-details { overflow: hidden; }
         .account-email { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
         .account-plan { font-size: 0.85em; color: var(--text-secondary); }
         #auth-controls { margin-top: 15px; text-align: center; }
         #auth-controls button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 8px 15px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease; }
         #auth-controls button:hover { background-color: var(--button-hover-bg); }
         #logout-btn { display: none; }

        /* Chat Area Elements */
        .greeting { font-size: 1.8em; font-weight: 600; margin-bottom: 40px; color: var(--text-primary); } .greeting .asterisk { color: var(--accent-color); font-size: 1.2em; margin-right: 5px; display: inline-block; vertical-align: middle; }
        .message { padding: 12px 18px; border-radius: 18px; max-width: 80%; word-wrap: break-word; line-height: 1.6; margin-bottom: 15px; font-size: var(--message-font-size); transition: background-color 0.3s ease, color 0.3s ease; }
        .user-message { background-color: var(--user-message-bg); color: var(--user-message-text); align-self: flex-end; border-bottom-right-radius: 5px; }
        .ai-message { background-color: var(--ai-message-bg); color: var(--ai-message-text); align-self: flex-start; border-bottom-left-radius: 5px; }
        .ai-message strong { font-weight: 600; } .ai-message em { font-style: italic; }
        .ai-message pre { background-color: var(--code-bg); color: var(--text-primary); padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 0.9em; transition: background-color 0.3s ease, color 0.3s ease; }
        .ai-message code { font-family: monospace; background-color: var(--code-bg); color: var(--text-primary); padding: 2px 4px; border-radius: 3px; transition: background-color 0.3s ease, color 0.3s ease;}
        .ai-message pre code { background-color: transparent; padding: 0; }
        .ai-message.thinking { background-color: transparent; color: var(--text-secondary); font-style: italic; }
        .error-message { background-color: var(--error-bg); color: var(--error-text); border: 1px solid var(--error-border); align-self: flex-start; transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;}
        .info-message { text-align: center; color: var(--text-secondary); padding: 50px 20px; font-style: italic; }
        .message .multi-media-indicator { font-size: 0.9em; color: var(--text-secondary); margin-top: 8px; display: block; font-style: italic;}
        .message mjx-container { color: inherit !important; font-size: inherit !important; }
        .message img.chat-image, .message img.uploaded-image { max-width: 100%; height: auto; border-radius: 8px; margin-top: 8px; cursor: pointer; display: block; }
        .message img.uploaded-image { border: 1px solid var(--border-color); margin-bottom: 5px; }
        .message .youtube-embed-container { margin-top: 10px; }
        .message iframe.chat-video { max-width: 100%; aspect-ratio: 16 / 9; border: none; border-radius: 8px; }
        .message .chat-audio-player { margin-top: 10px; width: 100%; max-width: 350px; }
        .message .chat-audio-player audio { width: 100%; height: 40px; border-radius: 20px; }

        /* Input Area Elements */
        .suggestions { display: none; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .suggestion-chip { background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 16px; padding: 8px 15px; font-size: 0.9em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
        .suggestion-chip:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .input-box { display: flex; align-items: flex-end; background-color: var(--main-bg); border: 1px solid var(--input-border-color); border-radius: 12px; padding: 5px 5px 5px 15px; position: relative; transition: background-color 0.3s ease, border-color 0.3s ease; }
        .input-box:focus-within { border-color: var(--input-focus-border-color); }
        .input-buttons { display: flex; align-self: center; margin-right: 5px; gap: 3px; }
        #image-upload-button, #pdf-upload-button, #audio-upload-button, #record-audio-button { background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 1.4em; padding: 0 4px; line-height: 1; transition: color 0.2s ease, opacity 0.2s ease; }
        #image-upload-button:hover, #pdf-upload-button:hover, #audio-upload-button:hover, #record-audio-button:hover:not(.recording) { color: var(--text-primary); }
        #image-upload-button:disabled, #pdf-upload-button:disabled, #audio-upload-button:disabled, #record-audio-button:disabled:not(.recording) { opacity: 0.5; cursor: not-allowed; color: var(--text-secondary); }
        #record-audio-button.recording { color: var(--record-button-bg); animation: pulse 1.5s infinite; }
        #record-audio-button.recording:disabled { color: var(--stop-button-bg); opacity: 0.7; animation: none; cursor: default; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        #user-input { flex-grow: 1; border: none; outline: none; padding: 10px 5px; font-size: 1rem; background-color: transparent; resize: none; min-height: 48px; max-height: 250px; line-height: 1.5; color: var(--text-primary); font-family: var(--font-family); }
        #user-input::placeholder { color: var(--text-placeholder); }
        .mcq-mode-control { display: flex; align-items: center; margin-left: 10px; padding-bottom: 8px; flex-shrink: 0; }
        .mcq-mode-control input[type="checkbox"] { margin-right: 5px; accent-color: var(--accent-color); cursor: pointer;}
        .mcq-mode-control label { font-size: 0.85em; color: var(--text-secondary); cursor: pointer; user-select: none;}
        #send-button { background-color: var(--send-button-bg); color: var(--send-button-text); border: none; border-radius: 8px; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-left: 10px; transition: background-color 0.2s ease; padding: 0; flex-shrink: 0; }
        #send-button:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #send-button:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.6; }
        #send-button svg { width: 20px; height: 20px; fill: currentColor; }

        /* Media Previews */
        #media-preview-container { margin-bottom: 10px; padding: 8px; background-color: var(--preview-bg); border: 1px solid var(--preview-border); border-radius: 8px; display: none; flex-direction: column; gap: 8px; }
        #image-previews-list { display: flex; gap: 8px; flex-wrap: wrap; max-height: 120px; overflow-y: auto; }
        .pdf-preview-item { background-color: var(--main-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-size: 0.85em; display: flex; align-items: center; gap: 6px; }
        .pdf-preview-item span { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; }
        .pdf-preview-item button { background: none; border: none; color: var(--remove-btn-color); cursor: pointer; font-size: 1.1em; line-height: 1; padding: 0 2px; margin-left: 4px; flex-shrink: 0; }
        .pdf-preview-item button:hover { color: var(--remove-btn-hover-color); }
        .image-preview-item { position: relative; }
        .image-preview-item img { max-height: 50px; max-width: 80px; height: auto; width: auto; border-radius: 4px; object-fit: cover; display: block; border: 1px solid var(--border-color); }
        .remove-image-item-button { position: absolute; top: -5px; right: -5px; background-color: rgba(0, 0, 0, 0.6); color: white; border: none; border-radius: 50%; width: 16px; height: 16px; font-size: 10px; line-height: 16px; text-align: center; cursor: pointer; opacity: 0.8; transition: opacity 0.2s ease; }
        .remove-image-item-button:hover { opacity: 1; }
        #preview-audio-container { display: flex; align-items: center; gap: 8px; display: none; }
        #preview-audio-container audio { height: 30px; max-width: 250px; }
        .media-preview-footer { display: flex; align-items: center; width: 100%; }
        #media-preview-info { font-size: 0.85em; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; }
        #remove-media-button { background: none; border: none; color: var(--remove-btn-color); cursor: pointer; font-size: 1.4em; line-height: 1; padding: 0 5px; transition: color 0.2s ease; margin-left: auto; flex-shrink: 0; }
        #remove-media-button:hover { color: var(--remove-btn-hover-color); }

         #recording-status { font-size: 0.85em; color: var(--text-secondary); margin-bottom: 5px; display: none; text-align: center; padding: 3px 0; }
         #recording-status.visible { display: block; }

        .thinking::after { content: ' .'; animation: dots 1s steps(3, end) infinite; display: inline-block; }
        @keyframes dots { 0%, 20% { content: ' .'; } 40% { content: ' ..'; } 60%, 100% { content: ' ...'; } }
         .start-test-button { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 8px 15px; margin-top: 10px; cursor: pointer; font-weight: 500; display: inline-block; transition: background-color 0.2s ease; }
         .start-test-button:hover { background-color: var(--send-button-hover-bg); }

        /* Mock Test & Review View Styles */
        .mock-test-view { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--main-bg); z-index: 100; flex-direction: column; padding: 20px; box-sizing: border-box; transition: background-color 0.3s ease; }
        .mock-test-view.active { display: flex; }
        .test-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .test-header h2 { margin: 0; font-size: 1.3em; color: var(--text-primary); }
        .test-info { display: flex; align-items: center; }
        .test-info span { margin-left: 15px; font-size: 0.95em; color: var(--text-secondary); }
        #test-language-toggle, #review-language-toggle { margin-left: 15px; padding: 3px 8px; font-size: 0.8em; cursor: pointer; background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; transition: background-color 0.2s ease, color 0.2s ease; }
        #test-language-toggle:hover, #review-language-toggle:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .test-content { flex-grow: 1; overflow-y: auto; padding: 10px 20px; }
        .test-question-container { margin-bottom: 25px; }
        .test-question-number { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .test-question { font-size: 1.1em; line-height: 1.5; margin-bottom: 15px; color: var(--text-primary); }
        .test-options label { display: block; margin-bottom: 12px; background-color: var(--button-bg); padding: 12px 15px; border-radius: 6px; border: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease; color: var(--text-primary); }
        .test-options label:hover { background-color: var(--button-hover-bg); }
        .test-options input[type="radio"] { margin-right: 10px; accent-color: var(--accent-color); cursor: pointer;}
        .test-navigation { display: flex; justify-content: space-between; padding-top: 15px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; }
        .test-navigation button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 10px 20px; cursor: pointer; font-size: 0.95em; transition: background-color 0.2s ease; }
        .test-navigation button:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        .test-navigation button#submit-test-btn { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color); }
        .test-navigation button#submit-test-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        .test-navigation button:disabled { opacity: 0.5; cursor: not-allowed; }
        .review-view { padding: 20px; box-sizing: border-box; background-color: var(--main-bg); }
        .review-header { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        .review-header h2 { margin: 0 0 10px 0; font-size: 1.3em; color: var(--text-primary); }
        .review-summary { display: inline; }
        .review-summary span { margin-right: 20px; font-size: 1em; color: var(--text-primary); }
        .review-summary .score-correct { color: #28a745; font-weight: bold;} .review-summary .score-incorrect { color: #dc3545; font-weight: bold;} .review-summary .score-skipped { color: #fd7e14; font-weight: bold;}
        .review-filters { margin-top: 10px; margin-bottom: 15px; }
        .review-filters button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 5px 12px; margin-right: 8px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease, border-color 0.2s ease; }
        .review-filters button:hover { background-color: var(--button-hover-bg); }
        .review-filters button.active-filter { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color);}
        .review-content { flex-grow: 1; overflow-y: auto; padding-right: 10px; }
        .review-item { margin-bottom: 15px; padding: 15px; border: 1px solid var(--border-color); border-radius: 6px; background-color: var(--button-bg); transition: background-color 0.3s ease, border-color 0.3s ease; }
        .review-item.hidden-by-filter { display: none; }
        .review-item-qnum { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .review-item-question { margin-bottom: 10px; line-height: 1.5; color: var(--text-primary); }
        .review-item-details span { display: block; margin-bottom: 5px; font-size: 0.95em; color: var(--text-primary); }
        .review-item-details .correct-answer { color: #28a745; font-weight: bold; }
        .review-item-details .user-answer-correct { color: #28a745; } .review-item-details .user-answer-incorrect { color: #dc3545; text-decoration: line-through; } .review-item-details .user-answer-skipped { color: #fd7e14; font-style: italic; }
        .review-item-explanation { margin-top: 8px; font-size: 0.9em; color: var(--text-secondary); border-left: 3px solid var(--border-color); padding-left: 8px; line-height: 1.4; }
        .review-footer { text-align: center; padding-top: 20px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; display: flex; justify-content: center; gap: 15px; }
        #exit-review-btn, #save-review-btn { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 10px 25px; cursor: pointer; font-size: 1em; transition: background-color 0.2s ease; display: none; }
        #exit-review-btn:hover, #save-review-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #save-review-btn { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); }
        #save-review-btn:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        #save-review-btn:disabled { opacity: 0.6; cursor: not-allowed; background-color: #cccccc; border-color: #aaaaaa; }

        /* Responsive Design */
        @media (max-width: 768px) {
            :root { --sidebar-width: 200px; }
            .sidebar { padding: 10px 0; }
            .chat-area, .input-container { width: 95%; padding-left: 2.5%; padding-right: 2.5%; max-width: none; }
            .chat-area { padding-top: 15px; padding-bottom: 10px; }
            .input-container { padding-top: 10px; padding-bottom: 10px; }
            .message { max-width: 90%; font-size: calc(var(--message-font-size) * 0.95); }
            #image-upload-button, #pdf-upload-button, #audio-upload-button, #record-audio-button { font-size: 1.3em; padding: 0 3px; }
            #media-preview-container { padding: 6px; gap: 6px; }
            #image-previews-list { gap: 5px; max-height: 100px; }
            .pdf-preview-item { padding: 3px 6px; font-size: 0.8em; }
            .image-preview-item img { max-height: 40px; }
            .remove-image-item-button, .pdf-preview-item button { width: 14px; height: 14px; font-size: 9px; line-height: 14px; }
            #preview-audio-container audio { max-width: 180px; height: 28px; }
            #media-preview-info { font-size: 0.8em; }
            #remove-media-button { font-size: 1.3em; }
            .input-box { padding: 5px 5px 5px 10px; }
             #user-input { min-height: 40px; font-size: 0.95rem; }
             #send-button { width: 32px; height: 32px; }
             .mcq-mode-control label { font-size: 0.8em; }
            .mock-test-view, .review-view { padding: 10px; }
            .test-header, .review-header { margin-bottom: 15px; padding-bottom: 8px; flex-direction: column; align-items: flex-start; }
            .test-header h2, .review-header h2 { font-size: 1.1em; margin-bottom: 5px;}
            .test-info, .review-summary { margin-bottom: 5px; }
            .test-info span, .review-summary span { margin-left: 0; margin-right: 10px; font-size: 0.9em; display: inline-block; margin-bottom: 3px;}
            #test-language-toggle, #review-language-toggle { margin-left: 0; margin-top: 5px; font-size: 0.75em;}
            .test-content, .review-content { padding: 5px; }
            .test-question, .review-item-question { font-size: 1em; }
            .test-options label, .review-item { padding: 10px; font-size: 0.95em;}
            .review-filters { margin-top: 5px; }
            .review-filters button { padding: 4px 8px; font-size: 0.85em; margin-right: 5px;}
            .test-navigation, .review-footer { padding-top: 10px; }
            .test-navigation button, #exit-review-btn, #save-review-btn { padding: 8px 15px; font-size: 0.9em; }
        }
    </style>
</head>
<body>

    <div class="app-container" id="app-container">
        <div class="sidebar">
             <!-- Sidebar content -->
             <div class="sidebar-header">Gemini Chat</div>
             <div id="all-tests-section">
                 <div class="sidebar-section-title">All Tests</div>
                 <input type="search" id="test-search-input" placeholder="Search tests..." disabled>
                 <div class="all-tests-list" id="all-tests-list">
                      <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Login to see saved tests.</div>
                 </div>
             </div>
             <div class="sidebar-section">
                 <button class="start-chat-button" id="start-chat" disabled> <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg>
                      Start new chat
                 </button>
                 <div class="sidebar-section-title">Chats</div>
                 <div class="chat-list" id="chat-list">
                      <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in to see chats.</div>
                 </div>
             </div>
             <div class="sidebar-footer">
                  <div class="sidebar-controls">
                      <div class="text-size-controls">
                          <span>Text Size</span>
                          <div class="text-size-buttons"> <button id="decrease-text-size" title="Decrease text size" disabled>-</button> <button id="increase-text-size" title="Increase text size" disabled>+</button> </div>
                      </div>
                      <div class="theme-toggle"> <button id="theme-toggle-button" title="Toggle Theme" disabled>☀️</button> </div>
                  </div>
                   <div id="auth-controls"> <button id="login-google-btn">Login with Google</button> <button id="logout-btn" style="display: none;">Logout</button> </div>
                   <div class="account-info">
                       <div class="account-avatar" id="account-avatar">?</div>
                       <div class="account-details"> <div class="account-email" id="account-email">Not logged in</div> <div class="account-plan" id="account-plan"></div> </div>
                   </div>
             </div>
        </div>

        <div class="main-container">
            <div class="main-content active" id="main-content-chat">
                 <div class="chat-area" id="chat-area">
                     <!-- Greeting or Login Prompt -->
                 </div>
                 <div class="input-container" id="input-container">
                     <div class="suggestions" id="suggestions">
                          <button class="suggestion-chip" data-prompt="Summarize this document">Summarize this document</button>
                          <button class="suggestion-chip" data-prompt="Extract key points from this PDF">Extract key points from this PDF</button>
                          <button class="suggestion-chip" data-prompt="Describe this image">Describe this image</button>
                          <button class="suggestion-chip" data-prompt="Transcribe this audio">Transcribe this audio</button>
                     </div>
                    <div id="media-preview-container">
                        <div id="image-previews-list">
                            <!-- Image/PDF Previews -->
                        </div>
                        <div id="preview-audio-container">
                           <audio id="preview-audio" controls></audio>
                        </div>
                        <div class="media-preview-footer">
                            <span id="media-preview-info"></span>
                            <button id="remove-media-button" title="Remove all media">&times;</button>
                        </div>
                    </div>
                    <div id="recording-status">Recording... <span>0s</span></div>
                    <div class="input-box">
                         <input type="file" id="image-upload-input" accept="image/*" style="display: none;" multiple>
                         <input type="file" id="pdf-upload-input" accept="application/pdf" style="display: none;" multiple>
                         <input type="file" id="audio-upload-input" accept="audio/wav, audio/mp3, audio/mpeg, audio/aac, audio/ogg, audio/flac, audio/aiff" style="display: none;">
                         <div class="input-buttons">
                             <button id="image-upload-button" title="Upload image(s)" disabled>📎</button>
                             <button id="pdf-upload-button" title="Upload PDF file(s)" disabled>📄</button>
                             <button id="audio-upload-button" title="Upload audio file" disabled>🎵</button>
                             <button id="record-audio-button" title="Record audio" disabled>🎙️</button>
                         </div>
                         <textarea id="user-input" placeholder="Enter prompt, attach media, or paste URL" rows="1" disabled></textarea>
                         <div class="mcq-mode-control"> <input type="checkbox" id="mcq-mode-checkbox" title="Generate MCQs based on prompt/media" disabled> <label for="mcq-mode-checkbox">MCQs?</label> </div>
                         <button id="send-button" title="Send message" disabled> <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
                        </button>
                    </div>
                 </div>
            </div>
            <!-- Review View -->
            <div class="review-view" id="review-view">
                 <div class="review-header">
                     <h2 id="review-title">Test Review</h2>
                     <div>
                         <div class="review-summary" id="review-summary"></div>
                      </div>
                     <div class="review-filters" id="review-filters" style="display: none;"> <button data-filter="all" class="active-filter">All</button> <button data-filter="incorrect">Incorrect</button> <button data-filter="skipped">Skipped</button> </div>
                 </div>
                 <div class="review-content" id="review-content"></div>
                 <div class="review-footer"> <button id="save-review-btn">Save Review</button> <button id="exit-review-btn">Back</button> </div>
              </div>
        </div>
    </div>
    <!-- Mock Test View -->
    <div class="mock-test-view" id="mock-test-view">
         <div class="test-header">
            <h2 id="test-title">Mock Test</h2>
            <div class="test-info">
                <span id="question-counter">Q: 1 / N</span>
                <span id="test-timer">Time: 00:00</span>
             </div>
         </div>
         <div class="test-content">
            <div class="test-question-container"> <div class="test-question-number" id="test-question-number"></div> <div class="test-question" id="test-question"></div> <div class="test-options" id="test-options"></div> </div>
         </div>
         <div class="test-navigation"> <button id="prev-question-btn" disabled>Previous</button> <button id="next-question-btn">Next</button> <button id="submit-test-btn">Submit Test</button> </div>
    </div>


    <script>
        // --- Firebase Config ---
        const firebaseConfig = {
          apiKey: "AIzaSyDgw604fe5jnNu4kTOv1cQ-3n7PL8gcN58", // <- REPLACE IF NEEDED
          authDomain: "krish-c5db8.firebaseapp.com", // <- REPLACE IF NEEDED
          projectId: "krish-c5db8", // <- REPLACE IF NEEDED
          storageBucket: "krish-c5db8.appspot.com", // <- REPLACE IF NEEDED
          messagingSenderId: "217175257890", // <- REPLACE IF NEEDED
          appId: "1:217175257890:web:209f0f290eabab6b1fab7b", // <- REPLACE IF NEEDED
          measurementId: "G-97SHYGL2J4" // <- REPLACE IF NEEDED
        };

        // --- Initialize Firebase ---
        firebase.initializeApp(firebaseConfig);
        const fbAuth = firebase.auth();
        const db = firebase.firestore();

        // --- DOM Elements ---
        const appContainer = document.getElementById('app-container');
        const chatArea = document.getElementById('chat-area');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const suggestionsContainer = document.getElementById('suggestions');
        const startChatButton = document.getElementById('start-chat');
        const chatListContainer = document.getElementById('chat-list');
        const allTestsSection = document.getElementById('all-tests-section');
        const testSearchInput = document.getElementById('test-search-input');
        const allTestsListContainer = document.getElementById('all-tests-list');
        const accountEmail = document.getElementById('account-email');
        const accountAvatar = document.getElementById('account-avatar');
        const accountPlan = document.getElementById('account-plan');
        const decreaseTextBtn = document.getElementById('decrease-text-size');
        const increaseTextBtn = document.getElementById('increase-text-size');
        const themeToggleButton = document.getElementById('theme-toggle-button');
        const mainContainer = document.querySelector('.main-container');
        const chatView = document.getElementById('main-content-chat');
        const testView = document.getElementById('mock-test-view');
        const reviewView = document.getElementById('review-view');
        const inputContainer = document.getElementById('input-container');
        const mcqModeCheckbox = document.getElementById('mcq-mode-checkbox');
        const loginBtn = document.getElementById('login-google-btn');
        const logoutBtn = document.getElementById('logout-btn');
        // Test & Review Elements
        const testTitle = document.getElementById('test-title');
        const questionCounter = document.getElementById('question-counter');
        const testTimer = document.getElementById('test-timer');
        const testQuestionNumber = document.getElementById('test-question-number');
        const testQuestion = document.getElementById('test-question');
        const testOptionsContainer = document.getElementById('test-options');
        const prevQuestionBtn = document.getElementById('prev-question-btn');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const submitTestBtn = document.getElementById('submit-test-btn');
        const reviewTitle = document.getElementById('review-title');
        const reviewSummary = document.getElementById('review-summary');
        const reviewContent = document.getElementById('review-content');
        const exitReviewBtn = document.getElementById('exit-review-btn');
        const reviewFilters = document.getElementById('review-filters');
        const saveReviewBtn = document.getElementById('save-review-btn');
        // Media Elements
        const imageUploadButton = document.getElementById('image-upload-button');
        const imageUploadInput = document.getElementById('image-upload-input');
        const pdfUploadButton = document.getElementById('pdf-upload-button');
        const pdfUploadInput = document.getElementById('pdf-upload-input');
        const audioUploadButton = document.getElementById('audio-upload-button');
        const audioUploadInput = document.getElementById('audio-upload-input');
        const recordAudioButton = document.getElementById('record-audio-button');
        // Media Preview Elements
        const mediaPreviewContainer = document.getElementById('media-preview-container');
        const imagePreviewsList = document.getElementById('image-previews-list');
        const previewAudioContainer = document.getElementById('preview-audio-container');
        const previewAudio = document.getElementById('preview-audio');
        const mediaPreviewInfo = document.getElementById('media-preview-info');
        const removeMediaButton = document.getElementById('remove-media-button');
        // Recording Status
        const recordingStatus = document.getElementById('recording-status');
        const recordingTimerSpan = recordingStatus.querySelector('span');

        // --- Config & Constants ---
        const MODEL_NAME = "gemini-1.5-flash-latest";
        const STORAGE_KEY_API_KEY = 'geminiApiKey_insecureDemo';
        const NEW_CHAT_TITLE = "(New Chat)";
        const TEXT_SIZE_STEP = 0.1;
        const MIN_TEXT_SIZE_MULTIPLIER = 0.7;
        const MAX_TEXT_SIZE_MULTIPLIER = 1.5;
        const LIGHT_THEME_ICON = '☀️';
        const DARK_THEME_ICON = '🌙';
        const DELETE_ICON = '×';
        const EDIT_TEST_ICON = '✏️';
        const DELETE_TEST_ICON = '🗑️';
        const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})(?:\S+)?/i;
        const imageUrlRegex = /(?<!src=["'])(?<!href=["'])(https?:\/\/[^\s()<>]+?\.(?:jpg|jpeg|png|gif|webp|bmp))/gi;
        const MAX_IMAGE_SIZE_MB = 4;
        const MAX_TOTAL_IMAGE_SIZE_MB = 16;
        const MAX_IMAGE_COUNT = 5;
        const MAX_PDF_SIZE_MB = 50;
        const MAX_PDF_COUNT = 5;
        const MAX_AUDIO_SIZE_MB = 10;
        const SUPPORTED_AUDIO_MIMES = ['audio/wav', 'audio/mp3', 'audio/mpeg', 'audio/aiff', 'audio/aac', 'audio/ogg', 'audio/flac'];
        const RECORDING_TIME_LIMIT_SECONDS = 300; // 5 minutes

        // --- State Variables ---
        let API_KEY = '';
        let genAI = null; // GoogleGenerativeAI SDK instance
        let currentUser = null;
        let activeChatId = null;
        let currentChatHistory = []; // Stores history in {role, parts} format for SDK
        let currentTextSizeMultiplier = 1.0;
        let currentTheme = 'light';
        let isTestMode = false;
        let isReviewMode = false;
        let currentTestMCQs = [];
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let testStartTime = null;
        let testTimerInterval = null;
        let reviewResultsCache = null;
        let cameFromAllTestsList = false;
        let activeChatListener = null;
        let chatListListener = null;
        let testListListener = null;
        let isDeletingChat = false;
        let allSavedTestsData = [];
        let selectedMediaItems = []; // { type: 'image'/'audio'/'pdf', file, base64?, mimeType?, name, id }
        let nextMediaId = 0;
        // Audio Recording State
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingStartTime = null;
        let recordingTimerInterval = null;
        let recorderStream = null;
        // Flag for SDK loading state
        let isAISdkReady = false;

        // --- Initialization ---
        initializeApp();

        // --- Event Listeners ---
        sendButton.addEventListener('click', handleSendMessage);
        userInput.addEventListener('input', autoGrowTextarea);
        userInput.addEventListener('keydown', handleInputKeydown);
        suggestionsContainer.addEventListener('click', handleSuggestionClick);
        startChatButton.addEventListener('click', createNewChat);
        chatListContainer.addEventListener('click', handleChatListClick);
        allTestsListContainer.addEventListener('click', handleAllTestsListClick);
        testSearchInput.addEventListener('input', filterTestsInSidebar);
        decreaseTextBtn.addEventListener('click', () => adjustTextSize(-TEXT_SIZE_STEP));
        increaseTextBtn.addEventListener('click', () => adjustTextSize(TEXT_SIZE_STEP));
        themeToggleButton.addEventListener('click', toggleTheme);
        prevQuestionBtn.addEventListener('click', () => handleTestNavigation('prev'));
        nextQuestionBtn.addEventListener('click', () => handleTestNavigation('next'));
        submitTestBtn.addEventListener('click', submitTest);
        exitReviewBtn.addEventListener('click', exitReview);
        chatArea.addEventListener('click', handleChatAreaClick);
        reviewFilters.addEventListener('click', handleReviewFilterClick);
        saveReviewBtn.addEventListener('click', saveTestReviewToCloud);
        loginBtn.addEventListener('click', signInWithGoogle);
        logoutBtn.addEventListener('click', signOut);
        // Media Listeners
        imageUploadButton.addEventListener('click', () => {
            if (!imageUploadButton.disabled) imageUploadInput.click();
        });
        imageUploadInput.addEventListener('change', handleImageFileSelect);
        pdfUploadButton.addEventListener('click', () => {
            if (!pdfUploadButton.disabled) pdfUploadInput.click();
        });
        pdfUploadInput.addEventListener('change', handlePdfFileSelect);
        audioUploadButton.addEventListener('click', () => {
            if (!audioUploadButton.disabled) audioUploadInput.click();
        });
        audioUploadInput.addEventListener('change', handleAudioFileSelect);
        recordAudioButton.addEventListener('click', () => {
             if (!recordAudioButton.disabled || isRecording) {
                toggleRecording();
             }
        });
        removeMediaButton.addEventListener('click', removeAllSelectedMedia);

        // Listen for SDK loaded event (set by module script)
        window.addEventListener('google-ai-sdk-loaded', () => {
            console.log("Caught 'google-ai-sdk-loaded' event.");
            isAISdkReady = true;
            // If API key is already loaded, try initializing genAI now
            if (API_KEY && !genAI) {
                 initializeGenAIInstance();
                 // Re-evaluate button states if user is logged in
                 if(currentUser) updateButtonStates();
            }
        });


        // --- Initialization Functions ---
        async function initializeApp() {
            console.log("App Initializing (v9.9)...");
            setLoadingState(true, "Initializing...");
            chatArea.innerHTML = '';
            renderGreetingOrLoginPrompt();

            loadUserSettingsFromLocalStorage();
            await loadGeminiApiKey(); // Tries to load key and init SDK
            fbAuth.onAuthStateChanged(handleAuthStateChange); // Handles user state
            switchView('chat');
            // Don't focus input immediately, wait for state updates
            console.log("App Initialization Complete.");
        }

        async function loadGeminiApiKey() {
             console.log("Attempting to load Gemini API Key...");
             API_KEY = localStorage.getItem(STORAGE_KEY_API_KEY);
             if(!API_KEY){
                 console.warn("!!! SECURITY WARNING !!! Using insecure API key storage.");
                 API_KEY=prompt("--- INSECURE DEMO --- Please enter your Gemini API Key:");
                 if(API_KEY){
                     localStorage.setItem(STORAGE_KEY_API_KEY, API_KEY);
                     console.log("Saved insecure API Key.");
                 } else {
                     console.error("Gemini API Key is required.");
                     displayMessage("Gemini API Key is required for AI features.", 'ai', ['error-message']);
                     API_KEY = ''; genAI = null; isAISdkReady = false;
                     updateButtonStates(); return false;
                 }
             } else { console.log("Loaded insecure API Key."); }

             if (API_KEY && isAISdkReady && !genAI) { return initializeGenAIInstance(); }
             else if (API_KEY && !isAISdkReady) { console.log("API Key loaded, but AI SDK not ready yet."); return true; }
             else { return !!API_KEY; }
        }

        function initializeGenAIInstance() {
            if (!API_KEY || !isAISdkReady || genAI) { console.warn("Skipping genAI initialization. Conditions not met."); return false; }
            console.log("Initializing GoogleGenerativeAI SDK instance...");
            try {
                 if (window.GoogleGenerativeAI) {
                     genAI = new window.GoogleGenerativeAI(API_KEY);
                     console.log("GoogleGenerativeAI SDK instance created successfully.");
                     return true;
                 } else { console.error("GoogleGenerativeAI SDK constructor not found."); displayError("Error: AI SDK loaded but failed to initialize."); genAI = null; isAISdkReady = false; return false; }
            } catch (e) {
                 console.error("Error initializing GoogleGenerativeAI:", e);
                 displayError(`Error initializing AI SDK: ${e.message}. Check API Key.`);
                 API_KEY = ''; localStorage.removeItem(STORAGE_KEY_API_KEY); genAI = null; isAISdkReady = false; return false;
            } finally { updateButtonStates(); }
        }


        // --- Authentication Functions ---
        async function signInWithGoogle() { /* ... (no changes needed) ... */ const provider = new firebase.auth.GoogleAuthProvider(); try { setLoadingState(true, "Logging in..."); await fbAuth.signInWithPopup(provider); } catch (error) { console.error("Google Sign-In Error:", error); displayError(`Login failed: ${error.message || 'Unknown error'}`); setLoadingState(false); } }
        async function signOut() { /* ... (no changes needed) ... */ try { setLoadingState(true, "Logging out..."); await fbAuth.signOut(); } catch (error) { console.error("Sign Out Error:", error); displayError(`Logout failed: ${error.message || 'Unknown error'}`); setLoadingState(false); } }

        function handleAuthStateChange(user) {
            console.log("Auth state changed. User:", user ? user.uid : 'None');
            setLoadingState(true, user ? "Loading user data..." : "Logging out...");

            // Clear previous state and listeners
            if (activeChatListener) { activeChatListener(); activeChatListener = null; console.log("Cleared active chat listener."); }
            if (chatListListener) { chatListListener(); chatListListener = null; console.log("Cleared chat list listener.");}
            if (testListListener) { testListListener(); testListListener = null; console.log("Cleared test list listener."); }
            stopRecording(true);
            chatArea.innerHTML = '';
            chatListContainer.innerHTML = `<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">${user ? 'Loading chats...' : 'Please log in...'}</div>`;
            allTestsListContainer.innerHTML = `<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">${user ? 'Loading tests...' : 'Login to see tests.'}</div>`;
            allTestsSection.classList.remove('visible');
            testSearchInput.value = '';
            activeChatId = null; currentChatHistory = []; isDeletingChat = false; allSavedTestsData = [];
            removeAllSelectedMedia();

            if (user) {
                currentUser = user; console.log("User logged in:", currentUser.uid);
                loginBtn.style.display = 'none'; logoutBtn.style.display = 'inline-block';
                accountEmail.textContent = currentUser.email || currentUser.displayName || `User`;
                accountAvatar.textContent = (currentUser.displayName || currentUser.email || 'U')[0].toUpperCase();
                accountPlan.textContent = "Firebase User";

                inputContainer.style.display = 'block';
                suggestionsContainer.style.display = 'flex';
                allTestsSection.classList.add('visible');

                loadUserSettings(currentUser.uid); // Applies theme/text size
                loadAndListenForChats(currentUser.uid); // Will update buttons via listener callback
                loadAndListenForTests(currentUser.uid);
                renderGreetingOrLoginPrompt();

            } else {
                currentUser = null; console.log("User logged out");
                loginBtn.style.display = 'inline-block'; logoutBtn.style.display = 'none';
                accountEmail.textContent = "Not logged in"; accountAvatar.textContent = '?'; accountPlan.textContent = "";

                inputContainer.style.display = 'none';
                suggestionsContainer.style.display = 'none';
                allTestsSection.classList.remove('visible');

                renderGreetingOrLoginPrompt();
                // Keep local theme/text size visual defaults
                currentTheme = localStorage.getItem('chatTheme') || 'light'; applyTheme();
                currentTextSizeMultiplier = parseFloat(localStorage.getItem('chatTextSizeMultiplier')) || 1.0; applyTextSize();
            }

            updateButtonStates(); // Update buttons based on new auth state
            setLoadingState(false); // Done with auth change
        }

        function renderGreetingOrLoginPrompt() { /* ... (no changes needed) ... */ chatArea.innerHTML = ''; const greetingElement = document.createElement('div'); greetingElement.classList.add('greeting'); if (currentUser) { greetingElement.innerHTML = `<span class="asterisk">*</span>Good day, ${currentUser.displayName || 'User'}!`; chatArea.appendChild(greetingElement); if (!activeChatId) { displayMessage("Select a chat from the list or start a new one.", 'ai'); } else if (!API_KEY || !genAI) { displayMessage("API Key missing or AI SDK failed to initialize. AI features are disabled. Please check API Key or reload.", 'ai', ['error-message']); } } else { greetingElement.innerHTML = `<span class="asterisk">*</span>Welcome!`; chatArea.appendChild(greetingElement); displayMessage("Please log in with Google to use the chat and save your history.", 'ai'); } scrollToBottom(true); }

        // --- Settings (Theme/Text Size) ---
        function loadUserSettingsFromLocalStorage() { /* ... (no changes needed) ... */ const savedTheme = localStorage.getItem('chatTheme'); const savedTextSize = localStorage.getItem('chatTextSizeMultiplier'); currentTheme = savedTheme || 'light'; currentTextSizeMultiplier = savedTextSize ? parseFloat(savedTextSize) : 1.0; applyTheme(); applyTextSize(); }
        async function loadUserSettings(userId) { /* ... (no changes needed) ... */ const userDocRef = db.collection('users').doc(userId); try { const docSnap = await userDocRef.get(); if (docSnap.exists) { const settings = docSnap.data(); currentTheme = settings.theme || currentTheme; currentTextSizeMultiplier = settings.textSizeMultiplier || currentTextSizeMultiplier; console.log("Loaded user settings from Firestore:", settings); } else { console.log("No user settings found in Firestore, using local/defaults."); } } catch (error) { console.error("Error loading user settings from Firestore:", error); } finally { applyTheme(); applyTextSize(); } }
        async function saveUserSettings() { /* ... (no changes needed) ... */ localStorage.setItem('chatTheme', currentTheme); localStorage.setItem('chatTextSizeMultiplier', currentTextSizeMultiplier.toString()); if (!currentUser) return; const userDocRef = db.collection('users').doc(currentUser.uid); const settings = { theme: currentTheme, textSizeMultiplier: currentTextSizeMultiplier }; try { await userDocRef.set(settings, { merge: true }); console.log("User settings saved to Firestore:", settings); } catch (error) { console.error("Error saving user settings to Firestore:", error); } }
        function applyTheme() { /* ... (no changes needed) ... */ if(currentTheme==='dark'){ document.body.classList.add('dark-theme'); themeToggleButton.textContent=LIGHT_THEME_ICON; themeToggleButton.title="Switch to Light Theme"; } else { document.body.classList.remove('dark-theme'); themeToggleButton.textContent=DARK_THEME_ICON; themeToggleButton.title="Switch to Dark Theme"; } }
        function toggleTheme() { /* ... (no changes needed) ... */ currentTheme = (currentTheme === 'light') ? 'dark' : 'light'; applyTheme(); saveUserSettings(); }
        function applyTextSize() { /* ... (no changes needed) ... */ const newSize = `calc(var(--message-font-size-base) * ${currentTextSizeMultiplier})`; document.documentElement.style.setProperty('--message-font-size', newSize); updateButtonStates(); }
        function adjustTextSize(change) { /* ... (no changes needed) ... */ let newMultiplier = Math.max(MIN_TEXT_SIZE_MULTIPLIER, Math.min(MAX_TEXT_SIZE_MULTIPLIER, currentTextSizeMultiplier + change)); newMultiplier = Math.round(newMultiplier * 10) / 10; if (newMultiplier !== currentTextSizeMultiplier) { currentTextSizeMultiplier = newMultiplier; applyTextSize(); saveUserSettings(); } }


        // --- Chat Storage & Loading (Firestore) ---
         function loadAndListenForChats(userId) { /* ... (no changes needed in logic, button updates handled centrally) ... */ if (chatListListener) { chatListListener(); chatListListener = null; } const chatsRef = db.collection('chats').where('userId', '==', userId).orderBy('lastUpdated', 'desc'); console.log(`Listening for chats for user ${userId}`); chatListListener = chatsRef.onSnapshot(snapshot => { if (isDeletingChat) { console.log("Skipping chat list update during delete."); return; } const chats = []; snapshot.forEach(doc => { chats.push({ id: doc.id, ...doc.data() }); }); console.log("Received chat list snapshot:", chats.length, "chats"); renderSidebarChatList(chats); let chatToLoad = activeChatId; if (!chatToLoad || !chats.some(c => c.id === chatToLoad)) { chatToLoad = chats.length > 0 ? chats[0].id : null; if (chatToLoad) console.log("Active chat gone or none selected, switching to newest:", chatToLoad); } if (chatToLoad && chatToLoad !== activeChatId) { switchChat(chatToLoad); } else if (chatToLoad && chatToLoad === activeChatId) { highlightActiveChatInSidebar(); updateButtonStates(); setLoadingState(false); } else { activeChatId = null; if (activeChatListener) { activeChatListener(); activeChatListener = null; } renderGreetingOrLoginPrompt(); updateButtonStates(); setLoadingState(false); } }, error => { console.error("Error listening for chats:", error); displayError("Could not load chat list."); chatListContainer.innerHTML = '<div style="padding:10px;color:var(--error-text);">Error loading chats.</div>'; setLoadingState(false); }); }
        function renderSidebarChatList(chats) { /* ... (no changes needed) ... */ chatListContainer.innerHTML = ''; if (!currentUser) { chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">Please log in.</div>'; return; } if (chats.length === 0) { chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">No chats yet. Start one!</div>'; } else { chats.forEach(chatData => { const itemElement = document.createElement('div'); itemElement.classList.add('chat-list-item'); let title = chatData.title; if (typeof title !== 'string' || !title.trim()) { title = '(Untitled Chat)'; } title = title.trim(); itemElement.textContent = title; itemElement.dataset.id = chatData.id; itemElement.title = title; const deleteBtn = document.createElement('button'); deleteBtn.classList.add('delete-chat-button'); deleteBtn.innerHTML = DELETE_ICON; deleteBtn.title = "Delete chat"; deleteBtn.dataset.id = chatData.id; itemElement.appendChild(deleteBtn); chatListContainer.appendChild(itemElement); }); } highlightActiveChatInSidebar(); }
        function highlightActiveChatInSidebar() { /* ... (no changes needed) ... */ const items = chatListContainer.querySelectorAll('.chat-list-item'); items.forEach(item => { item.classList.toggle('active', item.dataset.id === activeChatId); }); }


        // --- Media Handling Functions ---
        function handleImageFileSelect(event) { /* ... (no changes needed) ... */ console.log("handleImageFileSelect triggered"); if (selectedMediaItems.length > 0 && selectedMediaItems.some(item => item.type === 'pdf' || item.type === 'audio')) { alert("Cannot select images when PDF(s) or audio are already selected. Please remove other media first."); imageUploadInput.value = ''; return; } const files = event.target.files; if (!files || files.length === 0) { imageUploadInput.value = ''; return; } let currentImageCount = selectedMediaItems.filter(item => item.type === 'image').length; let addedCount = 0; let totalSizeMB = selectedMediaItems.reduce((sum, item) => sum + (item.file?.size || 0), 0) / 1024 / 1024; const allowedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif', 'image/bmp']; for (const file of files) { if (currentImageCount >= MAX_IMAGE_COUNT) { alert(`Maximum ${MAX_IMAGE_COUNT} images allowed.`); break; } if (!allowedTypes.includes(file.type)) { console.warn(`Skipping invalid file type: ${file.name} (${file.type})`); continue; } const fileSizeMB = file.size / 1024 / 1024; if (fileSizeMB > MAX_IMAGE_SIZE_MB) { alert(`Image "${file.name}" (${fileSizeMB.toFixed(1)}MB) exceeds ${MAX_IMAGE_SIZE_MB}MB limit.`); continue; } if (totalSizeMB + fileSizeMB > MAX_TOTAL_IMAGE_SIZE_MB) { alert(`Adding "${file.name}" would exceed total image size limit of ${MAX_TOTAL_IMAGE_SIZE_MB}MB.`); continue; } const mediaId = nextMediaId++; selectedMediaItems.push({ id: mediaId, type: 'image', file: file, base64: null, mimeType: file.type, name: file.name }); currentImageCount++; totalSizeMB += fileSizeMB; addedCount++; } if (addedCount > 0) { console.log(`Added ${addedCount} images. Total images: ${currentImageCount}`); displayMediaPreview(); } imageUploadInput.value = ''; }
        function handlePdfFileSelect(event) { /* ... (no changes needed) ... */ console.log("handlePdfFileSelect triggered"); if (selectedMediaItems.length > 0 && selectedMediaItems.some(item => item.type === 'image' || item.type === 'audio')) { alert("Cannot select PDF(s) when image(s) or audio are already selected. Please remove other media first."); pdfUploadInput.value = ''; return; } const files = event.target.files; if (!files || files.length === 0) { pdfUploadInput.value = ''; return; } let currentPdfCount = selectedMediaItems.filter(item => item.type === 'pdf').length; let addedCount = 0; for (const file of files) { if (currentPdfCount >= MAX_PDF_COUNT) { alert(`Maximum ${MAX_PDF_COUNT} PDF files allowed.`); break; } if (file.type !== 'application/pdf') { console.warn(`Skipping non-PDF file: ${file.name} (${file.type})`); continue; } const fileSizeMB = file.size / 1024 / 1024; if (fileSizeMB > MAX_PDF_SIZE_MB) { alert(`PDF "${file.name}" (${fileSizeMB.toFixed(1)}MB) exceeds ${MAX_PDF_SIZE_MB}MB limit.`); continue; } const mediaId = nextMediaId++; selectedMediaItems.push({ id: mediaId, type: 'pdf', file: file, name: file.name, mimeType: file.type }); currentPdfCount++; addedCount++; } if (addedCount > 0) { console.log(`Added ${addedCount} PDFs. Total PDFs: ${currentPdfCount}`); displayMediaPreview(); } pdfUploadInput.value = ''; }
        function handleAudioFileSelect(event) { /* ... (no changes needed) ... */ console.log("handleAudioFileSelect triggered"); if (selectedMediaItems.length > 0 && selectedMediaItems.some(item => item.type === 'image' || item.type === 'pdf')) { alert("Cannot select audio when image(s) or PDF(s) are already selected. Please remove other media first."); audioUploadInput.value = ''; return; } removeAllSelectedMedia(); const file = event.target.files[0]; if (!file) { audioUploadInput.value = ''; return; } if (!SUPPORTED_AUDIO_MIMES.includes(file.type)) { alert(`Unsupported audio file type: ${file.type}. Supported: ${SUPPORTED_AUDIO_MIMES.join(', ')}`); audioUploadInput.value = ''; return; } const fileSizeMB = file.size / 1024 / 1024; if (fileSizeMB > MAX_AUDIO_SIZE_MB) { alert(`Audio file too large (${fileSizeMB.toFixed(1)}MB). Max ${MAX_AUDIO_SIZE_MB}MB.`); audioUploadInput.value = ''; return; } const reader = new FileReader(); reader.onload = (e) => { const mediaId = nextMediaId++; selectedMediaItems = [{ id: mediaId, type: 'audio', file: file, base64: e.target.result, mimeType: file.type, name: file.name }]; console.log("Audio selected and read:", file.name); displayMediaPreview(); } reader.onerror = (error) => { console.error("Error reading audio file:", error); alert("Error reading audio file."); removeAllSelectedMedia(); }; audioUploadInput.value = ''; reader.readAsDataURL(file); }
        function displayMediaPreview() { /* ... (no changes needed) ... */ console.log("displayMediaPreview. Items:", selectedMediaItems.length); imagePreviewsList.innerHTML = ''; previewAudioContainer.style.display = 'none'; previewAudio.removeAttribute('src'); mediaPreviewInfo.textContent = ''; imagePreviewsList.style.flexDirection = ''; imagePreviewsList.style.alignItems = ''; if (selectedMediaItems.length === 0) { mediaPreviewContainer.style.display = 'none'; return; } const audioItem = selectedMediaItems.find(item => item.type === 'audio'); const imageItems = selectedMediaItems.filter(item => item.type === 'image'); const pdfItems = selectedMediaItems.filter(item => item.type === 'pdf'); let infoText = ""; if (audioItem) { imagePreviewsList.style.display = 'none'; try { previewAudio.src = audioItem.base64; previewAudio.load(); previewAudioContainer.style.display = 'flex'; infoText = `1 audio file: ${audioItem.name || 'Audio'}`; } catch (e) { console.error("Error setting audio src:", e); infoText = 'Error loading audio preview'; } } else if (imageItems.length > 0) { previewAudioContainer.style.display = 'none'; imagePreviewsList.style.display = 'flex'; imageItems.forEach(item => { if (!item.base64) { const reader = new FileReader(); reader.onload = (e) => { item.base64 = e.target.result; renderImagePreviewItem(item); }; reader.onerror = () => { item.base64 = '#error'; renderImagePreviewItem(item); }; reader.readAsDataURL(item.file); } else { renderImagePreviewItem(item); } }); infoText = `${imageItems.length} image(s) selected`; } else if (pdfItems.length > 0) { previewAudioContainer.style.display = 'none'; imagePreviewsList.style.display = 'flex'; imagePreviewsList.style.flexDirection = 'column'; imagePreviewsList.style.alignItems = 'stretch'; pdfItems.forEach(item => renderPdfPreviewItem(item)); infoText = `${pdfItems.length} PDF file(s) selected`; } mediaPreviewInfo.textContent = infoText; mediaPreviewContainer.style.display = 'flex'; }
        function renderImagePreviewItem(item) { /* ... (no changes needed) ... */ try { const existingItem = imagePreviewsList.querySelector(`.image-preview-item[data-media-id="${item.id}"]`); if (existingItem) return; const itemContainer = document.createElement('div'); itemContainer.classList.add('image-preview-item'); itemContainer.dataset.mediaId = item.id; const img = document.createElement('img'); img.src = item.base64 === '#error' ? '' : (item.base64 || ''); img.alt = item.base64 === '#error' ? 'Preview error' : (item.name || 'Image'); img.title = item.name || 'Image'; img.onerror = () => { img.alt = "Preview load error"; }; const removeBtn = document.createElement('button'); removeBtn.classList.add('remove-image-item-button'); removeBtn.innerHTML = '&times;'; removeBtn.title = `Remove ${item.name || 'image'}`; removeBtn.onclick = (e) => { e.stopPropagation(); removeSelectedMediaItem(item.id); }; itemContainer.appendChild(img); itemContainer.appendChild(removeBtn); imagePreviewsList.appendChild(itemContainer); } catch (e) { console.error("Error creating image preview element:", e); } }
        function renderPdfPreviewItem(item) { /* ... (no changes needed) ... */ try { const existingItem = imagePreviewsList.querySelector(`.pdf-preview-item[data-media-id="${item.id}"]`); if (existingItem) return; const itemContainer = document.createElement('div'); itemContainer.classList.add('pdf-preview-item'); itemContainer.dataset.mediaId = item.id; const icon = document.createElement('span'); icon.textContent = '📄'; icon.style.marginRight = '4px'; const nameSpan = document.createElement('span'); nameSpan.textContent = item.name || 'PDF File'; nameSpan.title = item.name || 'PDF File'; const removeBtn = document.createElement('button'); removeBtn.innerHTML = '&times;'; removeBtn.title = `Remove ${item.name || 'PDF'}`; removeBtn.onclick = (e) => { e.stopPropagation(); removeSelectedMediaItem(item.id); }; itemContainer.appendChild(icon); itemContainer.appendChild(nameSpan); itemContainer.appendChild(removeBtn); imagePreviewsList.appendChild(itemContainer); } catch (e) { console.error("Error creating PDF preview element:", e); } }
        function removeSelectedMediaItem(mediaId) { /* ... (no changes needed) ... */ console.log(`Removing media item ID: ${mediaId}`); selectedMediaItems = selectedMediaItems.filter(item => item.id !== mediaId); displayMediaPreview(); }
        function removeAllSelectedMedia() { /* ... (no changes needed) ... */ console.log("removeAllSelectedMedia called."); stopRecording(true); selectedMediaItems = []; nextMediaId = 0; imagePreviewsList.innerHTML = ''; previewAudio.removeAttribute('src'); previewAudioContainer.style.display = 'none'; mediaPreviewContainer.style.display = 'none'; mediaPreviewInfo.textContent = ''; imagePreviewsList.style.flexDirection = ''; imagePreviewsList.style.alignItems = ''; imageUploadInput.value = ''; pdfUploadInput.value = ''; audioUploadInput.value = ''; console.log("All selected media removed."); }

        // --- Audio Recording Functions ---
        async function toggleRecording() { /* ... (no changes needed) ... */ if (isRecording) { stopRecording(); } else { if (selectedMediaItems.some(item => item.type === 'image' || item.type === 'pdf')) { alert("Cannot record audio when images or PDFs are selected. Remove them first."); return; } const appReady = currentUser && API_KEY && genAI && activeChatId; if (!appReady || (sendButton.disabled && !isRecording) || userInput.placeholder.includes("Generating") || userInput.placeholder.includes("Sending") || userInput.placeholder.includes("Uploading")) { alert("Please wait for the current action to complete or ensure app is ready."); return; } await startRecording(); } }
        async function startRecording() { /* ... (no changes needed) ... */ console.log("Attempting to start recording..."); if (selectedMediaItems.length > 0) { alert("Cannot record audio when other media is selected."); return; } if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { alert("Audio recording is not supported."); return; } try { if (recorderStream) { recorderStream.getTracks().forEach(track => track.stop()); recorderStream = null; } const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); recorderStream = stream; console.log("Mic access granted."); recordAudioButton.disabled = true; let options = {}; const preferredMimeTypes = ['audio/ogg;codecs=opus', 'audio/webm;codecs=opus', 'audio/aac', 'audio/mp4']; for (const mimeType of preferredMimeTypes) { if (MediaRecorder.isTypeSupported(mimeType)) { options.mimeType = mimeType; break; } } mediaRecorder = new MediaRecorder(stream, options); const actualMimeType = mediaRecorder.mimeType; console.log("MediaRecorder init. Type:", actualMimeType); audioChunks = []; mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) audioChunks.push(e.data); }; mediaRecorder.onstop = () => { console.log("Recorder stopped."); if (recorderStream) { recorderStream.getTracks().forEach(track => track.stop()); recorderStream = null; } isRecording = false; recordingStatus.classList.remove('visible'); recordAudioButton.classList.remove('recording'); recordAudioButton.textContent = '🎙️'; recordAudioButton.title = 'Record audio'; if (recordingTimerInterval) clearInterval(recordingTimerInterval); if (audioChunks.length === 0) { console.warn("No audio data."); updateButtonStates(); return; } const audioBlob = new Blob(audioChunks, { type: actualMimeType }); audioChunks = []; const fileSizeMB = audioBlob.size / 1024 / 1024; if (audioBlob.size === 0) { alert("Recording failed: No data."); updateButtonStates(); return; } if (fileSizeMB > MAX_AUDIO_SIZE_MB) { alert(`Audio too large (${fileSizeMB.toFixed(1)}MB). Max ${MAX_AUDIO_SIZE_MB}MB.`); updateButtonStates(); return; } const reader = new FileReader(); reader.onloadend = () => { if (reader.result?.startsWith('data:')) { let finalMimeType = actualMimeType.split(';')[0]; const mediaId = nextMediaId++; selectedMediaItems = [{ id: mediaId, type: 'audio', file: new File([audioBlob], `recording.audio`, { type: finalMimeType }), base64: reader.result, mimeType: finalMimeType, name: `recording-${new Date().toISOString().substring(0, 19).replace(/[:T]/g, '-')}.${finalMimeType.split('/')[1] || 'audio'}` }]; displayMediaPreview(); } else { alert("Error processing recorded audio."); } updateButtonStates(); }; reader.onerror = (error) => { alert("Error processing recorded audio."); updateButtonStates(); }; reader.readAsDataURL(audioBlob); setLoadingState(true, "Processing audio..."); }; mediaRecorder.onerror = (e) => { alert(`Recording error: ${e.error?.name || 'Unknown'}`); stopRecording(true); }; mediaRecorder.start(); isRecording = true; recordingStartTime = Date.now(); recordAudioButton.classList.add('recording'); recordAudioButton.textContent = '🛑'; recordAudioButton.title = 'Stop recording'; recordingStatus.classList.add('visible'); recordingTimerSpan.textContent = '0s'; setLoadingState(true, "Recording..."); recordingTimerInterval = setInterval(() => { const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000); recordingTimerSpan.textContent = `${elapsed}s`; if (elapsed >= RECORDING_TIME_LIMIT_SECONDS) { stopRecording(); alert(`Stopped after ${RECORDING_TIME_LIMIT_SECONDS} seconds.`); } }, 1000); console.log("Recording started."); recordAudioButton.disabled = false; } catch (error) { console.error("Error starting recording:", error); if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') { alert("Mic access denied."); } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') { alert("No mic found."); } else { alert(`Could not start recording: ${error.name}`); } stopRecording(true); } }
        function stopRecording(force = false) { /* ... (no changes needed) ... */ console.log("stopRecording called. isRecording:", isRecording, "force:", force); if (mediaRecorder && (isRecording || force)) { try { if (mediaRecorder.state === "recording" || mediaRecorder.state === "paused") { mediaRecorder.stop(); console.log("MediaRecorder.stop() called."); } else if (force) { console.log("Recorder not active, forcing cleanup."); resetRecordingUI(); } } catch (error) { console.error("Error calling mediaRecorder.stop():", error); resetRecordingUI(); } } else if (force) { resetRecordingUI(); } else { console.log("Not recording or recorder not available."); } }
        function resetRecordingUI() { /* ... (no changes needed) ... */ console.log("Resetting recording UI/state."); isRecording = false; if (recordAudioButton) { recordAudioButton.classList.remove('recording'); recordAudioButton.textContent = '🎙️'; recordAudioButton.title = 'Record audio'; } if (recordingStatus) recordingStatus.classList.remove('visible'); if (recordingTimerInterval) { clearInterval(recordingTimerInterval); recordingTimerInterval = null; } if (recorderStream) { recorderStream.getTracks().forEach(track => track.stop()); console.log("Mic stream stopped (reset UI)."); recorderStream = null; } mediaRecorder = null; audioChunks = []; updateButtonStates(); }


        // --- Chat Creation, Deletion, Switching ---
        async function createNewChat() { /* ... (no changes needed) ... */ if (!currentUser || startChatButton.disabled) { displayError("Please log in or wait."); return; } setLoadingState(true, "Creating chat..."); removeAllSelectedMedia(); const newChatRef = db.collection('chats').doc(); const timestamp = firebase.firestore.FieldValue.serverTimestamp(); try { await newChatRef.set({ userId: currentUser.uid, title: NEW_CHAT_TITLE, createdAt: timestamp, lastUpdated: timestamp }); console.log("New chat created:", newChatRef.id); } catch (error) { console.error("Error creating new chat:", error); displayError("Failed to create chat."); setLoadingState(false); } }
        function handleChatListClick(event) { /* ... (no changes needed) ... */ const target = event.target; const deleteButton = target.closest('.delete-chat-button'); if (deleteButton) { event.stopPropagation(); const chatId = deleteButton.dataset.id; const chatListItem = deleteButton.closest('.chat-list-item'); const chatTitle = chatListItem?.textContent?.replace(deleteButton.textContent, '').trim() || 'this chat'; if (chatId) { confirmAndDeleteChat(chatId, chatTitle); } return; } const item = target.closest('.chat-list-item'); const clickedId = item?.dataset?.id; if (item && clickedId && clickedId !== activeChatId) { switchChat(clickedId); } }
        function confirmAndDeleteChat(chatId, chatTitle) { /* ... (no changes needed) ... */ if (!currentUser || !chatId) return; if (confirm(`Delete chat "${chatTitle}" permanently?`)) { deleteChatFromFirestore(chatId); } else { console.log(`Deletion cancelled for chat: ${chatId}`); } }
        async function deleteChatFromFirestore(chatId) { /* ... (no changes needed) ... */ if (!currentUser || !chatId) return; isDeletingChat = true; console.log(`[Delete Start] Chat: ${chatId}`); setLoadingState(true, "Deleting chat..."); const chatDocRef = db.collection('chats').doc(chatId); const messagesRef = chatDocRef.collection('messages'); try { const messagesSnapshot = await messagesRef.get(); if (!messagesSnapshot.empty) { const batch = db.batch(); messagesSnapshot.docs.forEach(doc => { batch.delete(doc.ref); }); await batch.commit(); console.log(`[Delete] Deleted ${messagesSnapshot.size} messages.`); } await chatDocRef.delete(); console.log(`[Delete Success] Chat doc: ${chatId}`); if (activeChatId === chatId) { activeChatId = null; currentChatHistory = []; if (activeChatListener) { activeChatListener(); activeChatListener = null; } chatArea.innerHTML = ''; renderGreetingOrLoginPrompt(); removeAllSelectedMedia(); } } catch (error) { console.error(`[Delete Error] Chat ${chatId}:`, error); displayError(`Failed to delete chat.`); } finally { isDeletingChat = false; setLoadingState(false); console.log(`[Delete End] Chat: ${chatId}`); } }
        function switchChat(chatId) { /* ... (no changes needed) ... */ if (!currentUser || !chatId || chatId === activeChatId) return; console.log("Switching to chat:", chatId); setLoadingState(true, "Loading chat..."); activeChatId = chatId; removeAllSelectedMedia(); highlightActiveChatInSidebar(); userInput.value = ''; autoGrowTextarea(); mcqModeCheckbox.checked = false; loadAndListenForActiveChat(chatId); }

        // --- Message Loading (Firestore) ---
        function loadAndListenForActiveChat(chatId) { /* ... (no changes needed) ... */ if (!currentUser || !chatId) { chatArea.innerHTML = ''; if (activeChatListener) { activeChatListener(); activeChatListener = null; } renderGreetingOrLoginPrompt(); updateButtonStates(); setLoadingState(false); return; } if (activeChatListener) { activeChatListener(); activeChatListener = null; } const messagesRef = db.collection('chats').doc(chatId).collection('messages').orderBy('timestamp', 'asc'); chatArea.innerHTML = ''; const loadingMsg = displayMessage("Loading chat history...", 'ai', ['thinking']); scrollToBottom(true); console.log(`Listening for messages in chat ${chatId}`); activeChatListener = messagesRef.onSnapshot(snapshot => { console.log(`Received messages snapshot for chat ${chatId}:`, snapshot.size, "messages"); removeMessageElement(loadingMsg); chatArea.innerHTML = ''; currentChatHistory = []; if (snapshot.empty && activeChatId === chatId) { const chatListItem = chatListContainer.querySelector(`.chat-list-item[data-id="${chatId}"]`); const chatTitle = chatListItem?.textContent?.replace(DELETE_ICON, '').trim() || ''; if (chatTitle && chatTitle !== NEW_CHAT_TITLE) { displayMessage("Chat is empty. Send a message to start!", 'ai'); } else { renderGreetingOrLoginPrompt(); } } else { snapshot.forEach(doc => { const msgData = doc.data(); const role = msgData.role === 'user' ? 'user' : 'model'; const parts = []; if (msgData.text) parts.push({ text: msgData.text }); currentChatHistory.push({ role: role, parts: parts.filter(p => p.text) }); displayMessage(msgData.text || '', msgData.role, [], null, msgData); }); } scrollToBottom(true); updateButtonStates(); setLoadingState(false); if (!isTestMode && !isReviewMode && activeChatId) { setTimeout(() => userInput.focus(), 100); } }, error => { console.error(`Error listening messages chat ${chatId}:`, error); displayError("Could not load messages for this chat."); removeMessageElement(loadingMsg); chatArea.innerHTML = ''; currentChatHistory = []; updateButtonStates(); setLoadingState(false); }); }

        // --- File Upload Helper (Gemini File API) ---
        // *** FIXED: Use genAI.files.upload and genAI.files.get ***
        async function uploadAndProcessFile(file, index, totalFiles) {
            if (!genAI) throw new Error("AI SDK not initialized.");
            const progressMsg = `Uploading file ${index + 1}/${totalFiles}: ${file.name}...`;
            console.log(`[File API] ${progressMsg}`);
            setLoadingState(true, progressMsg);

            try {
                // 1. Upload the file using genAI.files.upload
                const uploadResult = await genAI.files.upload({ // <--- FIX: Use genAI.files.upload
                    file: file, mimeType: file.type, displayName: file.name,
                });
                const uploadedFile = uploadResult.file; // Get the file object from the response
                console.log(`[File API] Uploaded ${uploadedFile.name}. State: ${uploadedFile.state}`);

                // 2. Poll for processing completion using genAI.files.get
                let fileResponse = await genAI.files.get(uploadedFile.name); // <--- FIX: Use genAI.files.get
                const startTime = Date.now();
                const timeoutMs = 180000;

                while (fileResponse.file.state === 'PROCESSING') {
                    if (Date.now() - startTime > timeoutMs) { throw new Error(`File processing timed out for ${file.name}.`); }
                    const processMsg = `Processing file ${index + 1}/${totalFiles}: ${file.name}...`;
                    setLoadingState(true, processMsg);
                    console.log(`[File API] File ${file.name} state: ${fileResponse.file.state}. Waiting...`);
                    await new Promise(resolve => setTimeout(resolve, 5000));
                    try {
                        fileResponse = await genAI.files.get(uploadedFile.name); // <--- FIX: Use genAI.files.get
                    } catch (pollError) {
                        console.error(`[File API] Error polling file ${uploadedFile.name}:`, pollError);
                        throw new Error(`Error checking processing status for ${file.name}.`);
                    }
                }

                // 3. Check final state
                if (fileResponse.file.state !== 'ACTIVE') {
                    console.error(`[File API] File processing failed for ${file.name}. State: ${fileResponse.file.state}`, fileResponse);
                    throw new Error(`File processing for ${file.name} resulted in state: ${fileResponse.file.state}.`);
                }

                console.log(`[File API] File ${file.name} processed successfully. URI: ${fileResponse.file.uri}`);
                return fileResponse.file;
            } catch (uploadError) {
                 console.error(`[File API] Error during upload/processing for ${file.name}:`, uploadError);
                 throw uploadError;
            }
        }

        // --- Message Sending (Gemini API & Firestore Save) ---
        // *** No changes needed here, the fix was in uploadAndProcessFile ***
        async function handleSendMessage() { /* ... (same as v9.8) ... */ const userMessageTextRaw = userInput.value.trim(); const mediaItemsToSend = [...selectedMediaItems]; console.log("handleSendMessage: Text:", userMessageTextRaw, "Media items:", mediaItemsToSend.length); if (!currentUser) { displayError("Please log in."); return; } if (!activeChatId) { displayError("Please select/create chat."); return; } if (!API_KEY || !genAI) { displayError("API Key/SDK not ready."); return; } if (!userMessageTextRaw && mediaItemsToSend.length === 0) { return; } if (sendButton.disabled || isRecording) { console.log("Send disabled."); return; } setLoadingState(true, "Preparing message..."); userInput.value = ''; autoGrowTextarea(); const isMCQRequest = mcqModeCheckbox.checked; if (isMCQRequest) mcqModeCheckbox.checked = false; removeAllSelectedMedia(); const timestamp = firebase.firestore.FieldValue.serverTimestamp(); const messagesColRef = db.collection('chats').doc(activeChatId).collection('messages'); const chatDocRef = db.collection('chats').doc(activeChatId); const userMsgData = { role: "user", text: userMessageTextRaw, timestamp: timestamp }; const singleAudioItem = mediaItemsToSend.find(item => item.type === 'audio'); const imageItems = mediaItemsToSend.filter(item => item.type === 'image'); const pdfItems = mediaItemsToSend.filter(item => item.type === 'pdf'); let potentialTestTitle = null; if (singleAudioItem) { userMsgData.mediaType = 'audio'; userMsgData.mediaData = singleAudioItem.base64; userMsgData.mediaMimeType = singleAudioItem.mimeType; userMsgData.mediaName = singleAudioItem.name; } else if (imageItems.length === 1) { userMsgData.mediaType = 'image'; userMsgData.mediaName = imageItems[0].name; userMsgData.mediaMimeType = imageItems[0].mimeType; if (!imageItems[0].base64) { try { imageItems[0].base64 = await readFileAsBase64(imageItems[0].file); } catch (e) { console.error("Error reading image for DB:", e);}} userMsgData.mediaData = imageItems[0].base64; } else if (imageItems.length > 1) { userMsgData.mediaType = 'multi-image'; userMsgData.mediaCount = imageItems.length; userMsgData.mediaNames = imageItems.map(img => img.name); } else if (pdfItems.length > 0) { userMsgData.mediaType = 'multi-pdf'; userMsgData.mediaCount = pdfItems.length; userMsgData.mediaNames = pdfItems.map(pdf => pdf.name); } const youtubeMatch = userMessageTextRaw.match(youtubeRegex); if (youtubeMatch) userMsgData.youtubeVideoId = youtubeMatch[1]; try { const chatSnap = await chatDocRef.get(); let isFirstUserMessageInNewChat = false; if (chatSnap.exists && chatSnap.data().title === NEW_CHAT_TITLE) { const messagesSnap = await messagesColRef.limit(1).get(); if (messagesSnap.empty) { isFirstUserMessageInNewChat = true; } } await messagesColRef.add(userMsgData); await chatDocRef.update({ lastUpdated: timestamp }); console.log("User message saved."); if (isFirstUserMessageInNewChat) { let titleSource = userMessageTextRaw || (mediaItemsToSend[0]?.name) || "New Chat"; const generatedTitle = generateChatTitle(titleSource); if (generatedTitle && generatedTitle !== NEW_CHAT_TITLE) { await updateActiveChatTitle(generatedTitle); } } } catch(error) { console.error("Error saving user message:", error); displayError("Failed to save message."); setLoadingState(false); return; } const thinking = displayMessage("Thinking...", 'ai', ['thinking']); scrollToBottom(); const partsForApi = []; let userTextForPrompt = userMessageTextRaw; if (isMCQRequest) { let baseTitle = userMessageTextRaw || (mediaItemsToSend[0]?.name) || "Generated Test"; potentialTestTitle = generateChatTitle(baseTitle) + ` (${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })})`; const mcqInstructions = `\n\nPlease generate multiple choice questions based on the provided text and/or media (image(s)/PDF(s)/audio). Provide the response *only* as a valid JSON array string, enclosed within \`\`\`json ... \`\`\`. Each object in the array must have "question" (object with "en" and "ta" strings), "options" (array of 4 objects with "en" and "ta" strings), "answer" (string 'A', 'B', 'C', or 'D'), and "explanation" (object with "en" and "ta" strings). Provide accurate English content only. Do not include any text outside the JSON structure.`; userTextForPrompt = userTextForPrompt ? userTextForPrompt + mcqInstructions : mcqInstructions; console.log("MCQ mode: Modified prompt."); } if (userTextForPrompt) partsForApi.push({ text: userTextForPrompt }); try { if (singleAudioItem) { const base64Data = singleAudioItem.base64.substring(singleAudioItem.base64.indexOf(',') + 1); partsForApi.push({ inlineData: { mimeType: singleAudioItem.mimeType, data: base64Data } }); console.log(`Added audio inlineData.`); } else if (imageItems.length > 0) { const imageBase64Promises = imageItems.map(item => item.base64 || readFileAsBase64(item.file)); const imageBase64Results = await Promise.all(imageBase64Promises); imageBase64Results.forEach((b64, index) => { const mime = imageItems[index].mimeType; const data = b64.substring(b64.indexOf(',') + 1); if(data && mime) partsForApi.push({ inlineData: { mimeType: mime, data: data } }); else console.error(`Missing data/mime for image: ${imageItems[index].name}`); }); console.log(`Added ${imageItems.length} images as inlineData.`); } else if (pdfItems.length > 0) { console.log(`Uploading ${pdfItems.length} PDF(s) via File API...`); const uploadPromises = pdfItems.map((item, index) => uploadAndProcessFile(item.file, index, pdfItems.length)); const uploadedFiles = await Promise.all(uploadPromises); uploadedFiles.forEach(file => { if (file?.uri && file?.mimeType) { partsForApi.push({ fileData: { mimeType: file.mimeType, fileUri: file.uri } }); } else { console.error("Upload result missing URI/mimeType:", file); throw new Error("Failed to get complete PDF details."); } }); console.log(`Added ${pdfItems.length} PDFs as fileData.`); } if (partsForApi.length === 0) { throw new Error("No valid content to send."); } console.log("Calling Gemini API via SDK..."); setLoadingState(true, "Generating response..."); const model = genAI.getGenerativeModel({ model: MODEL_NAME, safetySettings: [ { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }, { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" }, { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }, { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }, ] }); const historyForSDK = currentChatHistory.map(msg => ({ role: msg.role, parts: msg.parts.filter(part => part.text) })).filter(msg => msg.parts.length > 0); const contentsRequest = [ ...historyForSDK, { role: "user", parts: partsForApi } ]; const result = await model.generateContent({ contents: contentsRequest }); const response = result.response; removeMessageElement(thinking); let aiMsgData = { role: "model", text: "Error: No valid response.", timestamp: firebase.firestore.FieldValue.serverTimestamp(), mcqData: null, mcqTitle: null }; let displayAsError = true; let rawAiText = ""; let blocked = false; if (response.promptFeedback?.blockReason) { aiMsgData.text = `Blocked (Prompt): ${response.promptFeedback.blockReason}`; blocked = true; displayAsError = true; console.warn("Prompt blocked:", response.promptFeedback); } else if (response.candidates && response.candidates.length > 0) { const candidate = response.candidates[0]; if (candidate.finishReason === 'SAFETY') { aiMsgData.text = `Blocked (Safety): ${candidate.safetyRatings?.map(r => `${r.category.replace('HARM_CATEGORY_','')} (${r.probability})`).join(', ') || 'Reason'}`; blocked = true; displayAsError = true; console.warn("Response blocked (Safety):", candidate.safetyRatings); } else if (candidate.finishReason === 'RECITATION') { aiMsgData.text = `Blocked (Recitation)`; blocked = true; displayAsError = true; console.warn("Response blocked (Recitation)"); } else if (candidate.content?.parts?.length > 0) { try { rawAiText = response.text(); aiMsgData.text = rawAiText; displayAsError = false; if (isMCQRequest && !blocked) { try { const jsonMatch = rawAiText.match(/```json\s*([\s\S]*?)\s*```/); const jsonString = jsonMatch ? jsonMatch[1].trim() : rawAiText.trim(); if (jsonString.startsWith('[') && jsonString.endsWith(']')) { const mcqs = JSON.parse(jsonString); const isValid = Array.isArray(mcqs) && mcqs.length > 0 && mcqs.every(q => q.question?.en && q.options?.length === 4 && q.options.every(opt=>opt.en) && q.answer && q.explanation?.en); if (isValid) { mcqs.forEach(q => { q.question.ta = q.question.ta || q.question.en; q.explanation.ta = q.explanation.ta || q.explanation.en; q.options.forEach(opt => { opt.ta = opt.ta || opt.en; }); }); aiMsgData.text = `Generated ${mcqs.length} MCQs.`; aiMsgData.mcqData = mcqs; aiMsgData.mcqTitle = potentialTestTitle; console.log("MCQs parsed."); displayAsError = false; } else { throw new Error("Invalid MCQ structure."); } } else { throw new Error("Not a JSON array."); } } catch (parseError) { console.warn("Failed to parse MCQ JSON:", parseError.message); aiMsgData.text = "MCQ format error.\n\n" + rawAiText; displayAsError = true; aiMsgData.mcqData = null; aiMsgData.mcqTitle = null; } } } catch (textError) { console.error("Error extracting text:", textError); aiMsgData.text = "Error extracting text."; displayAsError = true; } } else if (candidate.finishReason === 'MAX_TOKENS') { console.warn("Response stopped: MAX_TOKENS."); aiMsgData.text = rawAiText + "\n\n(Response may be truncated)"; displayAsError = false; } else { console.warn("API finish reason:", candidate.finishReason); aiMsgData.text = `Response finished: ${candidate.finishReason || 'Unknown'}`; displayAsError = false; } } else { console.error("API Error: No candidates."); aiMsgData.text = "Error: No response data."; displayAsError = true; } try { await messagesColRef.add(aiMsgData); await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() }); console.log("AI response/error saved."); } catch (saveError) { console.error("Error saving AI response:", saveError); displayError(`Failed to save AI response.`); } } catch (error) { console.error("Error during send process:", error); removeMessageElement(thinking); const errorText = `Error: ${error.message || "Send failed."}`; displayError(errorText); try { await messagesColRef.add({ role: "model", text: errorText, timestamp: firebase.firestore.FieldValue.serverTimestamp() }); await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() }); } catch (saveError) { console.error("Failed to save error message:", saveError); } } finally { setLoadingState(false); if (!isTestMode && !isReviewMode && activeChatId) { setTimeout(() => userInput.focus(), 100); } } }


        // --- Chat Title Generation/Update ---
        function generateChatTitle(sourceText) { /* ... (no changes needed) ... */ if (!sourceText || typeof sourceText !== 'string') return NEW_CHAT_TITLE; const text = sourceText.trim(); if (!text) return NEW_CHAT_TITLE; const title = text.split(/\s+/).slice(0, 5).join(' ').replace(/[.,!?;:]+$/, ''); return title.length > 35 ? title.substring(0, 32) + '...' : title; }
        async function updateActiveChatTitle(newTitle) { /* ... (no changes needed) ... */ if (!currentUser || !activeChatId || !newTitle || typeof newTitle !== 'string' || !newTitle.trim() || newTitle.trim() === NEW_CHAT_TITLE) return; const finalTitle = newTitle.trim(); const chatDocRef = db.collection('chats').doc(activeChatId); try { await chatDocRef.update({ title: finalTitle }); console.log(`Chat ${activeChatId} title updated: "${finalTitle}"`); } catch (error) { console.error("Error updating chat title:", error); } }

        // --- File Reader Helper ---
        function readFileAsBase64(file) { /* ... (no changes needed) ... */ return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = (error) => reject(error); reader.readAsDataURL(file); }); }

        // --- UI & Message Display Helpers ---
        function autoGrowTextarea() { /* ... (no changes needed) ... */ userInput.style.height='auto'; userInput.style.height=(userInput.scrollHeight)+'px'; }
        function handleInputKeydown(event) { /* ... (no changes needed) ... */ if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();if(!sendButton.disabled) handleSendMessage();} }
        function handleSuggestionClick(event) { /* ... (no changes needed) ... */ if(event.target.classList.contains('suggestion-chip')){userInput.value=event.target.dataset.prompt||'';autoGrowTextarea();userInput.focus();} }
        function displayError(text) { /* ... (no changes needed) ... */ console.error("Displaying Error:", text); displayMessage(`${text}`, 'ai', ['error-message']); scrollToBottom(); }
        function scrollToBottom(immediate = false) { /* ... (no changes needed) ... */ chatArea.scrollTo({top:chatArea.scrollHeight,behavior:immediate?'auto':'smooth'}); }
        function removeMessageElement(element) { /* ... (no changes needed) ... */ if(element && element.parentNode === chatArea) { try { chatArea.removeChild(element); } catch(e) { /* ignore */ } } }

        function updateButtonStates(isLoading = false) { /* ... (same as v9.8) ... */ const isLoggedIn = !!currentUser; const isSDKReady = !!(API_KEY && genAI); const isChatSelected = !!activeChatId; const isAppReady = isLoggedIn && isSDKReady; const canSendMessage = isAppReady && isChatSelected && !isLoading && !isRecording; const canUseSidebarControls = isLoggedIn && !isLoading && !isRecording; userInput.disabled = !isAppReady || !isChatSelected || isLoading || isRecording; sendButton.disabled = !canSendMessage; mcqModeCheckbox.disabled = !canSendMessage; imageUploadButton.disabled = !canSendMessage; pdfUploadButton.disabled = !canSendMessage; audioUploadButton.disabled = !canSendMessage; let recordButtonDisabled = !isAppReady || !isChatSelected || isLoading; if (isRecording) { recordButtonDisabled = false; } recordAudioButton.disabled = recordButtonDisabled; startChatButton.disabled = !isLoggedIn || isLoading || isRecording; testSearchInput.disabled = !isLoggedIn || isLoading || isRecording; decreaseTextBtn.disabled = !isLoggedIn || isLoading || isRecording || currentTextSizeMultiplier <= MIN_TEXT_SIZE_MULTIPLIER; increaseTextBtn.disabled = !isLoggedIn || isLoading || isRecording || currentTextSizeMultiplier >= MAX_TEXT_SIZE_MULTIPLIER; themeToggleButton.disabled = isLoading || isRecording; loginBtn.disabled = isLoading; logoutBtn.disabled = isLoading; }
        function setLoadingState(isLoading, message = "Generating...") { /* ... (same as v9.8) ... */ console.log(`setLoadingState: ${isLoading}, Message: ${message}`); updateButtonStates(isLoading); let placeholderText = ""; if (isRecording) { placeholderText = "Recording audio..."; } else if (isLoading) { placeholderText = message; } else if (!currentUser) { placeholderText = "Please log in"; } else if (!API_KEY || !genAI) { placeholderText = "API Key/SDK Error. Check settings."; } else if (!activeChatId) { placeholderText = "Select or create a chat"; } else { placeholderText = "Enter prompt, attach media, or paste URL"; } userInput.placeholder = placeholderText; }
        function switchView(viewName, cameFromTests = false) { /* ... (same as v9.8) ... */ console.log("Switching view to:", viewName); chatView.classList.remove('active'); reviewView.classList.remove('active'); testView.classList.remove('active'); appContainer.classList.remove('hidden'); isTestMode = false; isReviewMode = false; cameFromAllTestsList = cameFromTests; saveReviewBtn.style.display = 'none'; exitReviewBtn.style.display = 'none'; if(viewName === 'test'){ appContainer.classList.add('hidden'); testView.classList.add('active'); isTestMode = true; } else if(viewName === 'review'){ reviewView.classList.add('active'); isReviewMode = true; exitReviewBtn.style.display = 'inline-block'; exitReviewBtn.textContent = cameFromAllTestsList ? "Back to All Tests" : "Back to Chat"; } else { chatView.classList.add('active'); if (currentUser && activeChatId && API_KEY && genAI && !isRecording) { setTimeout(() => userInput.focus(), 100); } } if (viewName !== 'test' && testTimerInterval) { clearInterval(testTimerInterval); testTimerInterval = null; } }
        function displayMessage(text, sender, cssClasses = [], appendHtml = null, messageData = null) { /* ... (same as v9.8) ... */ const messageElement = document.createElement('div'); messageElement.classList.add('message', `${sender}-message`); if (cssClasses?.length > 0) messageElement.classList.add(...cssClasses); let hasContent = false; if (messageData?.mediaType === 'image' && messageData.mediaData) { try { const img = document.createElement('img'); img.src = messageData.mediaData; img.alt = messageData.mediaName || "Uploaded Image"; img.classList.add('uploaded-image'); img.loading = "lazy"; img.onerror = () => { img.alt = "Image load error"; img.src = ""; }; messageElement.appendChild(img); hasContent = true; } catch (e) { console.error("Error creating image element:", e); } } else if (messageData?.mediaType === 'multi-image' && messageData.mediaCount > 0) { try { const indicator = document.createElement('div'); indicator.classList.add('multi-media-indicator'); indicator.textContent = `(${messageData.mediaCount} image${messageData.mediaCount > 1 ? 's' : ''} sent: ${messageData.mediaNames?.join(', ') || ''})`; messageElement.appendChild(indicator); hasContent = true; } catch (e) { console.error("Error creating multi-image indicator:", e); } } else if (messageData?.mediaType === 'multi-pdf' && messageData.mediaCount > 0) { try { const indicator = document.createElement('div'); indicator.classList.add('multi-media-indicator'); indicator.textContent = `(${messageData.mediaCount} PDF${messageData.mediaCount > 1 ? 's' : ''} sent: ${messageData.mediaNames?.join(', ') || ''})`; messageElement.appendChild(indicator); hasContent = true; } catch (e) { console.error("Error creating multi-PDF indicator:", e); } } else if (messageData?.mediaType === 'audio' && messageData.mediaData) { try { const audioContainer = document.createElement('div'); audioContainer.classList.add('chat-audio-player'); const audioPlayer = document.createElement('audio'); audioPlayer.src = messageData.mediaData; audioPlayer.controls = true; audioPlayer.preload = "metadata"; if(messageData.mediaName) audioPlayer.title = messageData.mediaName; audioPlayer.onerror = () => { console.warn("Error loading audio player"); audioContainer.innerHTML = `<span style='font-size:0.8em; color:var(--error-text);'>(Audio load error)</span>`; }; audioContainer.appendChild(audioPlayer); messageElement.appendChild(audioContainer); hasContent = true; } catch (e) { console.error("Error creating audio element:", e); } } if (text) { const messageContentContainer = document.createElement('div'); try { const tempDiv = document.createElement('div'); tempDiv.innerText = text; let formattedText = tempDiv.innerHTML; if (messageData?.mediaType !== 'image') { formattedText = formattedText.replace(imageUrlRegex, (match, imgUrl) => `<img src="${imgUrl}" class="chat-image" alt="Chat Image" loading="lazy" onerror="this.alt='Image URL load error'; this.src='';">`); } formattedText = formattedText.replace(/```([\s\S]*?)```/g, (match, code) => `<pre><code>${code.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code></pre>`).replace(/`([^`]+)`/g, (match, code) => `<code>${code.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code>`).replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/(?<!\*)\*(?!\*)(.*?)(?<!\*)\*(?!\*)/g, '<em>$1</em>').replace(/\n/g, '<br>'); messageContentContainer.innerHTML = formattedText; messageElement.appendChild(messageContentContainer); hasContent = true; if (text.includes('$') || text.includes('\\') || text.includes('^') || text.includes('_')) { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { setTimeout(() => { MathJax.typesetPromise([messageContentContainer]).catch(err => console.error('MathJax typesetting error:', err)); }, 50); } } } catch (e) { console.error("Error formatting text content:", e); } } if (messageData?.youtubeVideoId) { try { const youtubeEmbedDiv = document.createElement('div'); youtubeEmbedDiv.classList.add('youtube-embed-container'); const iframe = document.createElement('iframe'); iframe.classList.add('chat-video'); iframe.src = `https://www.youtube.com/embed/${messageData.youtubeVideoId}`; iframe.title = "YouTube video player"; iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"; iframe.allowFullscreen = true; iframe.loading = "lazy"; iframe.onerror = () => { youtubeEmbedDiv.innerHTML = `<span style='font-size:0.8em; color:var(--error-text);'>(YouTube embed error)</span>`; }; youtubeEmbedDiv.appendChild(iframe); messageElement.appendChild(youtubeEmbedDiv); hasContent = true; } catch (e) { console.error("Error creating YouTube embed:", e); } } if (messageData?.role === 'model' && messageData?.mcqData?.length > 0) { try { displayMCQOffer(messageData.mcqData, messageData.mcqTitle, messageElement); hasContent = true; } catch (e) { console.error("Error displaying MCQ offer:", e); } } else if (appendHtml) { try { const appendDiv = document.createElement('div'); appendDiv.innerHTML = appendHtml; while (appendDiv.firstChild) { messageElement.appendChild(appendDiv.firstChild); } hasContent = true; } catch (e) { console.error("Error appending raw HTML:", e); } } if (hasContent || cssClasses.includes('thinking')) { chatArea.appendChild(messageElement); } else { console.warn(`Skipping display of empty message. Sender: ${sender}`); } return messageElement; }


        // --- MCQ/Test Specific Functions ---
        function handleChatAreaClick(event) { /* ... (no changes needed) ... */ const startButton = event.target.closest('.start-test-button'); if (startButton) { const mcqDataString = startButton.dataset.mcq; const titleFromButton = startButton.dataset.mcqTitle; let mcqs = null; if (mcqDataString) { try { mcqs = JSON.parse(mcqDataString); } catch (e) { console.error("Failed parse MCQ data from button:", e); displayError("Could not start test. Invalid data."); return; } } if (mcqs?.length > 0) { startMockTest(mcqs, titleFromButton || null); } else { displayError("MCQ data missing or invalid."); } return; } const clickedImage = event.target.closest('img.chat-image, img.uploaded-image'); if (clickedImage?.src && !clickedImage.src.startsWith('#') && clickedImage.src.trim() !== '') { try { if (!clickedImage.src.startsWith('data:image') || clickedImage.src.length < 2 * 1024 * 1024) { window.open(clickedImage.src, '_blank'); } else { console.log("Clicked large base64 image in chat."); } } catch (e) { console.error("Error opening image source:", e); } } }
        function displayMCQOffer(mcqData, mcqTitle, aiMessageElement) { /* ... (no changes needed) ... */ if (aiMessageElement.querySelector('.start-test-button')) return; const questionCount = mcqData.length; const button = document.createElement('button'); button.classList.add('start-test-button'); button.textContent = `Start Mock Test (${questionCount} Qs)`; button.title = mcqTitle || `Start generated test`; try { button.dataset.mcq = JSON.stringify(mcqData); if (mcqTitle) { button.dataset.mcqTitle = mcqTitle; } } catch (e) { console.error("Failed stringify MCQ data for button:", e); return; } const buttonContainer = document.createElement('div'); buttonContainer.style.marginTop = '10px'; buttonContainer.appendChild(button); aiMessageElement.appendChild(buttonContainer); }
        function startMockTest(mcqs, title = null) { /* ... (no changes needed) ... */ if (!currentUser) { displayError("Log in to start test."); return; } if (!mcqs?.length) { displayError("No questions for test."); if (cameFromAllTestsList) { switchView('chat'); } return; } console.log("Starting mock test:", mcqs.length, "Qs. Title:", title); currentTestMCQs = mcqs; currentQuestionIndex = 0; userAnswers = new Array(mcqs.length).fill(null); reviewResultsCache = null; switchView('test'); displayTestQuestion(0); startTestTimer(); const finalTitle = (title && title.trim()) ? title.trim() : `Mock Test (${mcqs.length} Qs)`; testTitle.textContent = finalTitle; }
        function displayTestQuestion(index) { /* ... (no changes needed) ... */ if (index < 0 || index >= currentTestMCQs.length) return; currentQuestionIndex = index; const questionData = currentTestMCQs[index]; const questionText = questionData.question?.en || "(Question missing)"; testQuestionNumber.textContent = `Question ${index + 1}`; testQuestion.innerHTML = questionText; testOptionsContainer.innerHTML = ''; const options = questionData.options || []; const optionLetters = ['A', 'B', 'C', 'D']; options.forEach((optionObj, optionIndex) => { if (optionIndex >= optionLetters.length) return; const optionText = optionObj?.en || '(Option missing)'; const label = document.createElement('label'); const input = document.createElement('input'); input.type = 'radio'; input.name = `q_${index}`; input.value = optionIndex; input.checked = (userAnswers[index] === optionIndex); input.onchange = () => handleOptionSelect(optionIndex); label.appendChild(input); label.appendChild(document.createTextNode(` ${optionLetters[optionIndex]}. ${optionText}`)); testOptionsContainer.appendChild(label); }); try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([testQuestion, testOptionsContainer]).catch(err=>console.error('MathJax Test Q Error:', err)); } } catch(e){ console.error("MathJax call failed in test:", e); } prevQuestionBtn.disabled = (index === 0); nextQuestionBtn.disabled = (index === currentTestMCQs.length - 1); questionCounter.textContent = `Q: ${index + 1} / ${currentTestMCQs.length}`; }
        function handleOptionSelect(optionIndex) { /* ... (no changes needed) ... */ if (currentQuestionIndex >= 0 && currentQuestionIndex < userAnswers.length) { userAnswers[currentQuestionIndex] = optionIndex; console.log(`Answered Q${currentQuestionIndex + 1}: Option ${optionIndex}`); } }
        function handleTestNavigation(direction) { /* ... (no changes needed) ... */ let newIndex = currentQuestionIndex; if (direction === 'prev' && currentQuestionIndex > 0) { newIndex--; } else if (direction === 'next' && currentQuestionIndex < currentTestMCQs.length - 1) { newIndex++; } if (newIndex !== currentQuestionIndex) { displayTestQuestion(newIndex); } }
        function startTestTimer() { /* ... (no changes needed) ... */ if (testTimerInterval) clearInterval(testTimerInterval); testStartTime = Date.now(); testTimer.textContent = `Time: 00:00`; testTimerInterval = setInterval(() => { const elapsedSeconds = Math.floor((Date.now() - testStartTime) / 1000); const minutes = Math.floor(elapsedSeconds / 60).toString().padStart(2, '0'); const seconds = (elapsedSeconds % 60).toString().padStart(2, '0'); testTimer.textContent = `Time: ${minutes}:${seconds}`; }, 1000); }
        function submitTest() { /* ... (no changes needed) ... */ if (!confirm("Submit test?")) return; if (testTimerInterval) clearInterval(testTimerInterval); const endTime = Date.now(); const timeTakenMs = testStartTime ? endTime - testStartTime : 0; const results = calculateResults(currentTestMCQs, userAnswers, timeTakenMs); reviewResultsCache = results; switchView('review', false); displayReview(results); }

        // --- Review Functions ---
        function calculateResults(mcqs, answers, timeMs) { /* ... (no changes needed) ... */ let correctCount = 0, incorrectCount = 0, skippedCount = 0; const reviewQuestions = []; mcqs.forEach((q, idx) => { const uAIdx = answers[idx]; const opts = q.options || []; const cALtr = q.answer?.trim().toUpperCase(); const cAIdx = cALtr ? cALtr.charCodeAt(0) - 'A'.charCodeAt(0) : -1; const cATxtE = (cAIdx >= 0 && cAIdx < opts.length) ? (opts[cAIdx]?.en || '?') : "N/A"; let uATxtE = "Skipped"; let st = "skipped"; if (uAIdx !== null && uAIdx >= 0 && uAIdx < opts.length) { uATxtE = opts[uAIdx]?.en || '?'; if (uAIdx === cAIdx) { st = "correct"; correctCount++; } else { st = "incorrect"; incorrectCount++; } } else if (uAIdx !== null) { uATxtE = "Invalid"; st = "incorrect"; incorrectCount++; } else { skippedCount++; } reviewQuestions.push({ question: q.question?.en || '?', correctAnswer: cATxtE, userAnswer: uATxtE, status: st, explanation: q.explanation?.en || "N/A" }); }); const total = mcqs.length; const score = `${correctCount}/${total}`; const timeS = Math.round(timeMs / 1000); const mins = Math.floor(timeS / 60); const secs = timeS % 60; const timeStr = `${mins}m ${secs}s`; return { questions: reviewQuestions, summary: { score, correct: correctCount, incorrect: incorrectCount, skipped: skippedCount, timeString: timeStr }, testDate: new Date().toISOString(), timeTakenMs: timeMs, sourceChatId: activeChatId, testTitle: testTitle.textContent, originalMCQs: mcqs }; }
        function displayReview(reviewData) { /* ... (no changes needed) ... */ reviewContent.innerHTML = ''; reviewSummary.innerHTML = ''; reviewFilters.style.display = 'none'; if (!reviewData?.questions?.length || !reviewData.summary || !reviewData.originalMCQs) { reviewSummary.innerHTML = "<span>No review data available.</span>"; saveReviewBtn.style.display = 'none'; return; } const { score, correct, incorrect, skipped, timeString } = reviewData.summary; reviewSummary.innerHTML = `<span>Score: ${score}</span> <span class="score-correct">Correct: ${correct}</span> <span class="score-incorrect">Incorrect: ${incorrect}</span> <span class="score-skipped">Skipped: ${skipped}</span> <span>Time: ${timeString}</span>`; reviewTitle.textContent = reviewData.testTitle || "Test Review"; reviewData.questions.forEach((qSum, idx) => { const origQ = reviewData.originalMCQs[idx]; if (!origQ) return; const qTxt = origQ.question?.en || '?'; const opts = origQ.options || []; const cALtr = origQ.answer?.trim().toUpperCase(); const cAIdx = cALtr ? cALtr.charCodeAt(0) - 'A'.charCodeAt(0) : -1; const cATxt = (cAIdx >= 0 && cAIdx < opts.length) ? (opts[cAIdx]?.en) : "N/A"; let uATxt = qSum.userAnswer; const st = qSum.status; if (st === 'skipped') uATxt = "Skipped"; else if (st === 'invalid') uATxt = "Invalid"; const explTxt = origQ.explanation?.en || "N/A."; let iStCls = `status-${st}`; let aDtCls = `user-answer-${st}`; const rItem = document.createElement('div'); rItem.classList.add('review-item', iStCls); rItem.dataset.status = st; let dHtml = `<span class="${aDtCls}">Your Answer: ${uATxt}</span>`; if (st !== 'correct') { dHtml += `<br><span class="correct-answer">Correct Answer: ${cATxt}</span>`; } dHtml += `<div class="review-item-explanation">Explanation: ${explTxt}</div>`; rItem.innerHTML = `<div class="review-item-qnum">Q ${idx + 1}</div> <div class="review-item-question">${qTxt}</div> <div class="review-item-details">${dHtml}</div>`; reviewContent.appendChild(rItem); }); if (incorrect > 0 || skipped > 0) reviewFilters.style.display = 'block'; else reviewFilters.style.display = 'none'; if (reviewData.savedAt) { saveReviewBtn.textContent = "Saved"; saveReviewBtn.disabled = true; saveReviewBtn.style.display = 'inline-block'; } else if (reviewResultsCache && !cameFromAllTestsList) { saveReviewBtn.textContent = "Save Review"; saveReviewBtn.disabled = !currentUser; saveReviewBtn.style.display = 'inline-block'; } else { saveReviewBtn.style.display = 'none'; } filterReviewItems('all'); reviewFilters.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active-filter', btn.dataset.filter === 'all'); }); try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([reviewContent]).catch(err=>console.error('MathJax Review Error:', err)); } } catch (e) { console.error("MathJax call failed in review:", e); } }
        function handleReviewFilterClick(event) { /* ... (no changes needed) ... */ const button = event.target.closest('button[data-filter]'); if (button) { filterReviewItems(button.dataset.filter); } }
        function filterReviewItems(filter) { /* ... (no changes needed) ... */ reviewFilters.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active-filter', btn.dataset.filter === filter); }); reviewContent.querySelectorAll('.review-item').forEach(item => { const show = (filter === 'all') || item.dataset.status === filter; item.classList.toggle('hidden-by-filter', !show); }); }
        function exitReview() { /* ... (no changes needed) ... */ reviewResultsCache = null; switchView('chat'); reviewSummary.innerHTML = ''; reviewContent.innerHTML = ''; reviewTitle.textContent = 'Review'; }
        async function saveTestReviewToCloud() { /* ... (no changes needed) ... */ if (!currentUser) { alert("Please log in to save the review."); return; } if (!reviewResultsCache || reviewResultsCache.savedAt) { alert("No new review data to save or already saved."); return; } if (!reviewResultsCache.originalMCQs?.length || !reviewResultsCache.summary) { if (!confirm("Warning: Review data seems incomplete. Save anyway?")) { return; } } const dataToSave = { ...reviewResultsCache, userId: currentUser.uid, savedAt: firebase.firestore.FieldValue.serverTimestamp(), }; saveReviewBtn.disabled = true; saveReviewBtn.textContent = "Saving..."; try { const newRef = await db.collection('testReviews').add(dataToSave); console.log("Review saved:", newRef.id); alert("Review saved!"); saveReviewBtn.textContent = "Saved"; if (reviewResultsCache) reviewResultsCache.savedAt = new Date(); } catch (error) { console.error("Error saving review:", error); alert("Failed to save review."); saveReviewBtn.disabled = false; saveReviewBtn.textContent = "Save Review"; } }

        // --- All Tests List Functions ---
        function loadAndListenForTests(userId) { /* ... (no changes needed) ... */ if (testListListener) { testListListener(); testListListener = null; } const testsRef = db.collection('testReviews').where('userId', '==', userId).orderBy('savedAt', 'desc'); console.log(`Listening for saved tests for user ${userId}`); testListListener = testsRef.onSnapshot(snapshot => { allSavedTestsData = []; snapshot.forEach(doc => { allSavedTestsData.push({ id: doc.id, ...doc.data() }); }); console.log("Received saved tests snapshot:", allSavedTestsData.length, "tests"); renderAllTestsList(allSavedTestsData); filterTestsInSidebar(); }, error => { console.error("Error listening for saved tests:", error); allTestsListContainer.innerHTML = `<div style="padding:10px; color:var(--error-text);">Error loading saved tests.</div>`; allSavedTestsData = []; }); }
        function renderAllTestsList(tests) { /* ... (no changes needed) ... */ allTestsListContainer.innerHTML = ''; if (!currentUser) { allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">Login to see tests.</div>'; return; } if (tests.length === 0) { allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">No saved tests found.</div>'; } else { tests.forEach(testData => { const item = document.createElement('div'); item.classList.add('test-list-item'); item.dataset.reviewId = testData.id; const title = testData.testTitle || '(Untitled Test)'; const date = testData.savedAt?.toDate ? testData.savedAt.toDate().toLocaleString() : 'Unknown date'; const score = testData.summary?.score || 'N/A'; const hasReattemptData = testData.originalMCQs?.length > 0 && testData.originalMCQs.every(q => q?.question && q.options && q.answer && q.explanation); const infoDiv = document.createElement('div'); infoDiv.classList.add('test-item-info'); const titleSpan = document.createElement('span'); titleSpan.classList.add('test-item-title'); titleSpan.textContent = title; titleSpan.title = title; const detailSpan = document.createElement('span'); detailSpan.classList.add('test-item-details'); detailSpan.textContent = `Saved: ${date} | Score: ${score}`; const controlsDiv = document.createElement('div'); controlsDiv.classList.add('test-item-controls'); const editButton = document.createElement('button'); editButton.innerHTML = EDIT_TEST_ICON; editButton.title = "Edit title"; editButton.dataset.action = "edit-title"; controlsDiv.appendChild(editButton); const deleteButton = document.createElement('button'); deleteButton.innerHTML = DELETE_TEST_ICON; deleteButton.title = "Delete test"; deleteButton.dataset.action = "delete-test"; controlsDiv.appendChild(deleteButton); infoDiv.appendChild(titleSpan); infoDiv.appendChild(detailSpan); infoDiv.appendChild(controlsDiv); const actionsDiv = document.createElement('div'); actionsDiv.classList.add('test-item-actions'); const viewButton = document.createElement('button'); viewButton.textContent = "Details"; viewButton.dataset.action = "view"; actionsDiv.appendChild(viewButton); const reattemptSelect = document.createElement('select'); reattemptSelect.dataset.action = "reattempt"; reattemptSelect.disabled = !hasReattemptData; reattemptSelect.title = hasReattemptData ? "Reattempt test" : "Reattempt data not available"; reattemptSelect.innerHTML = `<option value="" selected>${hasReattemptData ? 'Reattempt...' : 'N/A'}</option> <option value="mistaked" ${!hasReattemptData?'disabled':''}>Mistaked Only</option> <option value="skipped" ${!hasReattemptData?'disabled':''}>Skipped Only</option> <option value="both" ${!hasReattemptData?'disabled':''}>Mistaked/Skipped</option> <option value="full" ${!hasReattemptData?'disabled':''}>Full Test</option>`; reattemptSelect.addEventListener('change', (e) => { const selectedMode = e.target.value; if (selectedMode) { const reviewId = e.target.closest('.test-list-item')?.dataset.reviewId; if (reviewId) { startReattempt(reviewId, selectedMode); } e.target.value = ""; } }); actionsDiv.appendChild(reattemptSelect); item.appendChild(infoDiv); item.appendChild(actionsDiv); allTestsListContainer.appendChild(item); }); } }
        function filterTestsInSidebar() { /* ... (no changes needed) ... */ const searchTerm = testSearchInput.value.toLowerCase().trim(); const items = allTestsListContainer.querySelectorAll('.test-list-item'); let visibleCount = 0; const noResultsMsg = allTestsListContainer.querySelector('.no-search-results'); if (noResultsMsg) { noResultsMsg.remove(); } items.forEach(item => { const title = item.querySelector('.test-item-title')?.textContent.toLowerCase() || ''; const details = item.querySelector('.test-item-details')?.textContent.toLowerCase() || ''; const isMatch = title.includes(searchTerm) || details.includes(searchTerm); item.classList.toggle('hidden-by-search', !isMatch); if (isMatch) visibleCount++; }); if (visibleCount === 0 && searchTerm !== '' && items.length > 0) { const msgDiv = document.createElement('div'); msgDiv.textContent = "No saved tests match your search."; msgDiv.classList.add('no-search-results'); allTestsListContainer.appendChild(msgDiv); } }
        async function handleAllTestsListClick(event) { /* ... (no changes needed) ... */ const button = event.target.closest('button[data-action]'); if (!button) return; const action = button.dataset.action; const listItem = button.closest('.test-list-item'); const reviewId = listItem?.dataset.reviewId; if (!reviewId) { console.error("Could not find review ID for action:", action); return; } switch (action) { case "view": const reviewData = allSavedTestsData.find(t => t.id === reviewId); if (reviewData) { reviewResultsCache = reviewData; switchView('review', true); displayReview(reviewData); } else { alert("Error: Could not find review data to display."); } break; case "edit-title": enterTestTitleEditMode(listItem, reviewId); break; case "delete-test": const testTitle = listItem.querySelector('.test-item-title')?.textContent || 'this test'; if (confirm(`Are you sure you want to delete the test "${testTitle}"?`)) { deleteSavedTest(reviewId, listItem); } break; } }
        function enterTestTitleEditMode(listItem, reviewId) { /* ... (no changes needed) ... */ const infoDiv = listItem.querySelector('.test-item-info'); const titleSpan = infoDiv.querySelector('.test-item-title'); const detailSpan = infoDiv.querySelector('.test-item-details'); const controlsDiv = infoDiv.querySelector('.test-item-controls'); const currentTitle = titleSpan.textContent; titleSpan.style.display = 'none'; detailSpan.style.display = 'none'; if(controlsDiv) controlsDiv.style.display = 'none'; if (infoDiv.querySelector('.test-item-edit-mode')) return; const editContainer = document.createElement('div'); editContainer.classList.add('test-item-edit-mode'); const input = document.createElement('input'); input.type = 'text'; input.value = currentTitle; input.maxLength = 100; input.addEventListener('keydown', (e) => { if (e.key === 'Enter') { saveTestTitle(listItem, reviewId, input.value); } else if (e.key === 'Escape') { exitTestTitleEditMode(listItem, currentTitle); } }); const saveButton = document.createElement('button'); saveButton.textContent = 'Save'; saveButton.onclick = () => saveTestTitle(listItem, reviewId, input.value); const cancelButton = document.createElement('button'); cancelButton.textContent = 'Cancel'; cancelButton.onclick = () => exitTestTitleEditMode(listItem, currentTitle); editContainer.appendChild(input); editContainer.appendChild(saveButton); editContainer.appendChild(cancelButton); infoDiv.appendChild(editContainer); input.focus(); input.select(); }
        function exitTestTitleEditMode(listItem, originalTitle = null) { /* ... (no changes needed) ... */ const infoDiv = listItem.querySelector('.test-item-info'); const titleSpan = infoDiv.querySelector('.test-item-title'); const detailSpan = infoDiv.querySelector('.test-item-details'); const controlsDiv = infoDiv.querySelector('.test-item-controls'); const editContainer = infoDiv.querySelector('.test-item-edit-mode'); if (editContainer) editContainer.remove(); if (originalTitle !== null && titleSpan) { titleSpan.textContent = originalTitle; titleSpan.title = originalTitle; } if(titleSpan) titleSpan.style.display = ''; if(detailSpan) detailSpan.style.display = ''; if(controlsDiv) controlsDiv.style.display = ''; }
        async function saveTestTitle(listItem, reviewId, newTitle) { /* ... (no changes needed) ... */ const trimmedTitle = newTitle.trim(); if (!trimmedTitle) { alert("Test title cannot be empty."); return; } if (trimmedTitle.length > 100) { alert("Test title is too long (max 100 characters)."); return; } const docRef = db.collection('testReviews').doc(reviewId); try { await docRef.update({ testTitle: trimmedTitle }); console.log("Test title updated successfully:", reviewId); const titleSpan = listItem.querySelector('.test-item-title'); if (titleSpan) { titleSpan.textContent = trimmedTitle; titleSpan.title = trimmedTitle; } const testIndex = allSavedTestsData.findIndex(t => t.id === reviewId); if (testIndex > -1) allSavedTestsData[testIndex].testTitle = trimmedTitle; exitTestTitleEditMode(listItem); } catch (error) { console.error("Error updating test title:", error); alert("Failed to update test title."); } }
        async function deleteSavedTest(reviewId, listItem) { /* ... (no changes needed) ... */ if (!currentUser || !reviewId) return; listItem.style.opacity = '0.5'; listItem.style.pointerEvents = 'none'; const docRef = db.collection('testReviews').doc(reviewId); try { await docRef.delete(); console.log("Saved test deleted successfully:", reviewId); /* Listener will handle UI update */ alert("Saved test deleted."); } catch (error) { console.error("Error deleting saved test:", error); alert("Failed to delete saved test."); listItem.style.opacity = '1'; listItem.style.pointerEvents = 'auto'; } }
        async function startReattempt(reviewId, mode) { /* ... (no changes needed) ... */ console.log(`Attempting reattempt for review ID: ${reviewId}, Mode: ${mode}`); const reviewData = allSavedTestsData.find(t => t.id === reviewId); if (!reviewData) { alert("Error: Could not find the saved review data for reattempt."); return; } const originalMCQs = reviewData.originalMCQs; const hasValidData = originalMCQs?.length > 0 && originalMCQs.every(q => q?.question && q.options && q.answer && q.explanation); if (!hasValidData) { alert("Error: Cannot reattempt. Original test data is missing or invalid."); return; } const summaryQuestions = reviewData.questions || []; let questionsForReattempt = []; switch (mode) { case 'mistaked': questionsForReattempt = originalMCQs.filter((mcq, index) => summaryQuestions[index]?.status === 'incorrect'); break; case 'skipped': questionsForReattempt = originalMCQs.filter((mcq, index) => summaryQuestions[index]?.status === 'skipped'); break; case 'both': questionsForReattempt = originalMCQs.filter((mcq, index) => summaryQuestions[index]?.status === 'incorrect' || summaryQuestions[index]?.status === 'skipped'); break; case 'full': default: questionsForReattempt = [...originalMCQs]; break; } if (questionsForReattempt.length === 0) { alert(`No questions found for the selected reattempt mode ('${mode}').`); return; } const originalTitle = reviewData.testTitle || 'Test'; const reattemptTitle = `${originalTitle} (Reattempt: ${mode})`; startMockTest(questionsForReattempt, reattemptTitle); }

    </script>

</body>
</html>
